# -*- coding: utf-8 -*-
""" 
class Elmer, enables to handle elmer as a transport tool
In fine should be able to launch elmer for linear and
non linear transport
The temperature is added as new, for the moment the last, problem unknown.
"""

from elmertools import *

from exceptions import Exception

from fields import *

from generictools import memberShip

from listtools import toList

#from tools import *

from listtools import elimCommonElementsInList

import os

import string

from types import NoneType

from vector import V

import WElmer

class Elmer():
    """ parent class used to define elmer as transport tool
        It enables to handle the following elmer keywords:
          Header
          Simulation
          Constants
          Body n
          Material n
          Body Force n
          Equation n
          Solver n
          Boundary Condition n
          Initial Condition n

    """
    def __init__(self, meshFileName="elmerMesh"):
        """	
        meshFileName : mesh file name, that the extension is .msh
        and that associated elmer format grid files are available
        """
	        
        self.__dict = {}
        self.advConv                    = None
        self.dirBCList                  = []
        self.dirICList                  = []
        print " dbg meshFileName: ",meshFileName.getName()[-4:]
        if meshFileName.getName()[-4:]  == ".msh":
	    self.meshFileName           = meshFileName.getName()
	    self.meshDirectoryName = self.meshFileName[0:-4]
	self.gravityDirection           = V(0,-1,0)
	self.gravityValue               = 9.78
	self.gravityValue               = 0.0
        self.mesh                       = None
        self.meshType                   = "grd"
        self.meshDico                   = Dico()
        self.bodyForce                  = None
        self.boundaryConditionConcDico  = Dico()
        self.parameterDico              = Dico()
        self.calculationTimesDico       = Dico()
        self.calculationType            = 1
        self.darcyVelocity              = None
        self.expectedOutputDico         = Dico()
        self.elmerZonesDico             = Dico()
        self.elmerNumberZoneDico        = Dico()
        self.effectiveDiffusionDico     = Dico()
        self.initialConditionConcDico   = Dico()
        self.lumpedMassMatrix           = None
        self.porosityDico               = Dico()
        self.sifFile                    = "test.sif"
        self.simulationType             = "transient"
        self.bdfOrder                   = "2"
        self.sorptionLawDico            = Dico()
        self.temperature                = None
        self.zonePerCellDico            = Dico()

        self.elmerZonesNamesList = []
        self.timespec = 0
        self.instance = 0
        if not hasattr(self,'problemType'):
            self.problemType='unknown'
            pass
        if self.problemType not in ['unknown','saturatedhydro','transienthydro','chemicaltransport']:
            raise Exception, " check the kind of problem you want to solve "
        # call to setDefaultParameters, settings of default tool parameters
        self.setDefaultParameters()
        self.outputs_point = None
        self.outputs_zone  = None
        self.outputs_surf  = None
        return None

    def createSifFile(self):
        self.sifFile = sifFile = open(self.sifFile,"w")
        sifFile.write("Check Keywords Warn\n\n")
        sifFile.write("Header\n")
        sifFile.write("Mesh DB \".\" \""+self.meshDirectoryName+"\"\nEnd\n\n")
        self.writeSimulation()
        self.writeConstants()
        self.writeBodies()
        self.writeMaterial()
#        if self.bodyForce: self.writeBodyForce()
        self.writeBodyForce()
        self.writeEquation()
        self.writeSolver()
        self.writeBoundaryCondition()
        self.writeInitialCondition()
        sifFile.close()
        
    def writeConstants(self):
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Constants\n! ~~\n")        
        sifFile.write("Constants\n")
        gVector = self.gravityDirection
        sifFile.write("  Gravity(4) = %i %i %i %e\n"%(gVector[0],gVector[1],gVector[2],self.gravityValue))
        sifFile.write("End\n\n")
        return None

    def writeBodies(self):
        """
        Bodies are asociated to materials and equations. Only one equation is treated when temperature is set to None. 
        Otherwise, two equations are taken into account. So, bodies are associated to initial conditions and their number
        mostly depends on material numbers.
        """
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Body\n! ~~\n")
        indb = 0
        ibc = 0
        for ibc in range(len(self.dirBCList)):
              
            sifFile.write("Body %i\n"%(ibc+1))
            sifFile.write("  Equation = 1\n")
            stinds = _digit(0)
            stindb = str(indb+1)+stinds
            sifFile.write("  Material = %s\n"%(stindb))
            sifFile.write("End\n\n")
#
# doit être modifie des que plusieurs materiaux interviennent
#            
        for  indb in range(len(self.dirICList)):
            sifFile.write("Body %i\n"%(indb+ibc+2))
            sifFile.write("  Equation = 1 \n")
            stinds = _digit(0)
            stindb = str(indb+1)+stinds
            sifFile.write("  Material = %s\n"%(stindb))
            sifFile.write("  Initial Condition = %s\n"%(indb+1))
#            sifFile.write("  Body Force = %s\n"%(indb+1))
            sifFile.write("  Body Force = %s\n"%(1))
            sifFile.write("End\n\n")
        return None

    def writeMaterial(self):
        """
        A loop over materials and species.
        Each material is associated to each species.
        The numbering is on three digits, two for the species, at least one for the region.
        For the moment, the material is independant of the species.
        """
       
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Material p29 ref. Manual\n! ~~\n")        
        for indb in range(len(self.bodies)):
            stinds = _digit(0)
            stindb = str(indb+1)+stinds
            sifFile.write("Material %s\n"%(stindb))
            sifFile.write(" Density = Real %15.10e\n"%(1.))
#
#       temperature: we get specificHeatCapacity and heatConductivity
#            
            if self.temperature==True:
                print " dbg temperature ",self.bodies[indb].getMaterial().getSpecificHeat().value
                print " dbg temperature ",self.bodies[indb].getMaterial().getThermalConductivity().value.value
                specificHeatCapacity    = self.bodies[indb].getMaterial().getSpecificHeat().value
                heatConductivity        = self.bodies[indb].getMaterial().getThermalConductivity().value.value
                sifFile.write(" Heat Capacity = Real %15.10e\n"%(specificHeatCapacity))
                sifFile.write(" Heat Conductivity = Real %15.10e\n"%(heatConductivity))
                pass
            sifFile.write(" Compressibility Model = Incompressible\n")
            tempcont = len(self.speciesNamesList)
            if self.temperature==True: tempcont = len(self.speciesNamesList)-1
            #sifFile.write(" Diffusivity = Real %15.10e\n"%(3.e-10))
            for inds in range(len(self.speciesNamesList)):
                effecDiff       = self.bodies[indb].getMaterial().getEffectiveDiffusion()
                print type(effecDiff),effecDiff.value.value
                if (type(effecDiff) not in [NoneType]):
                    effecDiff       = effecDiff.value.value
                else:
                    effecDiff       = 0.0
                porosity        = self.bodies[indb].getMaterial().getPorosity()
                print type(porosity),porosity.value
                if (porosity not in [NoneType]):
                    porosity        = porosity.value
                else:
                    porosity        = 0.0
                longDisp        = self.bodies[indb].getMaterial().getKinematicDispersion()
                print longDisp,type(longDisp)
                if (type(longDisp) not in [NoneType]):
                    longDisp        = longDisp.value[0]
                else:
                    longDisp        = 0.0
                v = None
                if type(self.darcyVelocity) != type(None):
                    v = self.darcyVelocity.getValue()
                    print " v ",v              
                if type(v)!=type(None):
                    norm = (v[0]**2+v[1]**2+v[2]**2)**0.5
                    if norm > 0:
                        darcy_x = v[0]**2/norm
                        darcy_y = v[1]**2/norm
                        darcy_z = v[2]**2/norm
                    else:
                        darcy_x = 0.0
                        darcy_y = 0.0
                        darcy_z = 0.0
                    
                else:
                    darcy_x = 0.0
                    darcy_y = 0.0
                    darcy_z = 0.0
#                print " we write the difusion ",effecDiff,darcy_x
                sifFile.write(" %s Diffusivity\n"%(self.speciesNamesList[inds]))
                sifFile.write("     Size 3 3\n")
                sifFile.write("      Real    %15.10e %15.10e %15.10e\\\n"    %(longDisp*darcy_x + effecDiff,0.,0.))
                sifFile.write("              %15.10e %15.10e %15.10e\\\n"    %(0.,longDisp*darcy_y + effecDiff,0.))
                sifFile.write("              %15.10e %15.10e %15.10e\\\n"    %(0.,0.,longDisp*darcy_z + effecDiff))
                sifFile.write(" End\n")
                
##                sifFile.write(" %s Diffusivity = Real %15.10e\n"%(self.speciesNamesList[inds],\
##                                  longDisp*darcy_x + effecDiff))
#                sifFile.write(" %s Soret Diffusivity = Real %15.10e\n"%(self.speciesNamesList[inds],\
#                                  self.bodies[indb].getMaterial().getThermalConductivity().value.value))
                sifFile.write("\n")

            if self.advConv == "Constant":
                v = self.darcyVelocity.getValue()
                sifFile.write(" Convection Velocity 1 = %e\n"%v[0])
                sifFile.write(" Convection Velocity 2 = %e\n"%v[1])
                sifFile.write(" Convection Velocity 3 = %e\n\n"%v[2])
            else:
                sifFile.write(" Convection Velocity 1 = %e\n"%0.0)
                sifFile.write(" Convection Velocity 2 = %e\n"%0.0)
                sifFile.write(" Convection Velocity 3 = %e\n\n"%0.0)
            
            sifFile.write("End\n\n")
        return None

    def writeBodyForce(self):
        sifFile = self.sifFile
        sifFile.write("! ~~~~~~~~~~\n! Body Force\n! ~~~~~~~~~~\n")        
        for  indb in range(len(self.dirICList)):
            if (indb==0):
                sifFile.write("Body Forces %i\n"%(indb+1))
                for inds in range(len(self.speciesNamesList)):
                    sifFile.write(" %s Diffusion Source = Real %15.10e\n"%(self.speciesNamesList[inds],0.0))
#                sifFile.write(" %5s Diffusion = Real %15.10e\n"%(self.speciesNamesList[inds],1.23456e-10))
#                Curvature Diffusion = Real 0.0
#                sifFile.write("Physical Units True \n")
#        sifFile.write("  Physical Units True \n")
        sifFile.write("End\n\n")
        return None

    def writeEquation(self):
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Equation p28 ref. Manual\n! ~~\n\n")
        ind = len(self.speciesNamesList)
        string = ""
        print " dbgy elmer writeEquation",self.speciesNamesList
        for ind in range(len(self.speciesNamesList)):
            string += str(ind+1)+" "
        ind+=1
            
        sifFile.write("Equation 1\n")
        sifFile.write("  Active Solvers(%i) = %s\n"%(ind,string))
        
        if self.advConv != None: sifFile.write("  Convection = %s\n"%self.advConv)
        sifFile.write("  Concentration Units = Absolute Mass\n")
               
        sifFile.write("End\n\n")
        return None
        
    def writeSolver(self):
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Solver p27 ref. Manual\n! ~~\n")
#
#                                                                                                               aqueous chemical unknowns treatment
#
        tempcont = len(self.speciesNamesList)
        print len(self.speciesNamesList)
        for ind in range(tempcont):      
            sifFile.write("Solver %i\n"%(ind+1))
            sifFile.write("  Equation = Advection Diffusion Equation %s\n"%(self.speciesNamesList[ind]))
            
            sifFile.write("  Variable = %s\n"%self.speciesNamesList[ind])
            sifFile.write("  Variable DOFs = 1\n\n")

            sifFile.write("  Procedure = \"AdvectionDiffusionTimeStep\" \"AdvectionDiffusionTimeStepSolver\"\n")
            sifFile.write("  Linear System Solver = %s\n"%self.parameterDico["Linear System Solver"])
            if self.parameterDico["algebraicResolution"] != "Direct":
                self.parameterDico['Linear System Solver']          = "Iterative"
            else:
                sifFile.write("  Linear System Direct Method = %s\n"%self.parameterDico["Linear System Direct Method"])

            sifFile.write("  Linear System Iterative Method = %s\n"%self.parameterDico["Linear System Iterative Method"])
            sifFile.write("  Linear System Max Iterations = %s\n"%self.parameterDico["Linear System Max Iterations"])
            sifFile.write("  Linear System Convergence Tolerance = %e\n"%self.parameterDico["Linear System Convergence Tolerance"])
            sifFile.write("  Linear System Preconditioning = %s\n"%self.parameterDico["Linear System Preconditioning"])
            sifFile.write("  Linear System ILUT Tolerance = %e\n"%self.parameterDico["Linear System Convergence Tolerance"])
            sifFile.write("  Linear System Symmetric = %s\n"%self.parameterDico["Linear System Symmetric"])
            sifFile.write("  Lumped Mass Matrix = %s\n"%self.parameterDico["Lumped Mass Matrix"])
                        
            sifFile.write("  Stabilize ="+self.parameterDico['Stabilize']+"\n")
            print "dbg stabil ",self.parameterDico['Stabilize']
            if self.parameterDico['Stabilize']=="True":
                sifFile.write("!  Bubbles "+self.parameterDico['Bubbles']+"\n")
            else:
                sifFile.write("!  Bubbles False\n")
            sifFile.write("  Namespace = string \"%s\"\n"%self.speciesNamesList[ind])
            sifFile.write("End\n\n")
#
#                       temperature treatment
#
        ind+=1
        if self.temperature:
            sifFile.write("Solver %i\n"%(ind))
            sifFile.write("  Equation = Heat Equation %s\n"%("temperature"))
            
            sifFile.write("  Variable = %s\n"%"temperature")
            sifFile.write("  Variable DOFs = 1\n\n")

            sifFile.write("  Procedure = \"AdvectionDiffusionTimeStep\" \"AdvectionDiffusionTimeStepSolver\"\n")
            sifFile.write("  Linear System Solver = %s\n"%self.parameterDico["Linear System Solver"])
            if self.parameterDico["algebraicResolution"] != "Direct":
                self.parameterDico['Linear System Solver']          = "Iterative"
            else:
                sifFile.write("  Linear System Direct Method = %s\n"%self.parameterDico["Linear System Direct Method"])

            sifFile.write("  Linear System Iterative Method = %s\n"%self.parameterDico["Linear System Iterative Method"])
            sifFile.write("  Linear System Max Iterations = %s\n"%self.parameterDico["Linear System Max Iterations"])
            sifFile.write("  Linear System Convergence Tolerance = %e\n"%self.parameterDico["Linear System Convergence Tolerance"])
            sifFile.write("  Linear System Preconditioning = %s\n"%self.parameterDico["Linear System Preconditioning"])
            sifFile.write("  Linear System ILUT Tolerance = %e\n"%self.parameterDico["Linear System Convergence Tolerance"])
            sifFile.write("  Linear System Symmetric = %s\n"%self.parameterDico["Linear System Symmetric"])
            sifFile.write("  Lumped Mass Matrix = %s\n"%self.parameterDico["Lumped Mass Matrix"])
                        
            sifFile.write("  Stabilize ="+self.parameterDico['Stabilize']+"\n")
            print "dbg stabil ",self.parameterDico['Stabilize']
            if self.parameterDico['Stabilize']=="True":
                sifFile.write("!  Bubbles "+self.parameterDico['Bubbles']+"\n")
            else:
                sifFile.write("!  Bubbles False\n")
            sifFile.write("  Namespace = string \"%s\"\n"%("temperature"))
            sifFile.write("End\n\n")
#            sifFile.write(" Solver 6\n")
#            sifFile.write(" Procedure = \"ResultOutputSolve\" \"ResultOutputSolver\"\n")
#            sifFile.write(" Output File Name = \"case\"\n")
#            sifFile.write(" Output Format = String VTK\n")
#            sifFile.write(" Scalar Field 1 = String Na\n")
#            sifFile.write(" End\n")
       

        if self.temperature == None:
            return None
        return None
        
    def writeBoundaryCondition(self):
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Material p29 ref. Manual\n! ~~\n")
        ##
        ## Two kinds of boundary conditions: Dirichlet or Flux
        ##
        for dirBC in self.dirBCList:
#            print " dbg write BC ",dirBC
            inds = 0
            print " bc elmer ",dirBC[0],dirBC[1],dirBC[2],dirBC[3]," inds ",inds
                                                                                                                ##
                                                                                                                ## Dirichlet
                                                                                                                ##
            print " elmer dbg ",dirBC[2].lower(),self.speciesNamesList,dirBC[-1]
            if (dirBC[2].lower()=="dirichlet"):
                stinds = _digit(inds)
                stindb = str(dirBC[1])+stinds
                sifFile.write("Boundary Condition %s\n"%stindb)
                sifFile.write("  Target Boundaries (1) = %s\n"%str(dirBC[1]))
                speciesNameList = self.speciesNamesList
                if self.temperature: self.speciesNamesList.append("temperature")
                for spconc in dirBC[-1]:
                    stinds = _digit(inds+1)
                    stindb = str(dirBC[1])+stinds
                    sifFile.write("  %s = Real %e\n"%(self.speciesNamesList[inds],spconc))
                    inds+=1
                sifFile.write("End\n\n")
            elif (dirBC[2].lower()=="flux"):
                                                                                                                ##
                                                                                                                ## Flux
                                                                                                                ##
###                stinds = _digit(inds)
#                stindb = str(dirBC[1])+stinds
#                sifFile.write("Boundary Condition %s\n"%stindb)
#                sifFile.write("  Target Boundaries (1) = %s\n"%str(dirBC[1]))
#                sifFile.write("  Mass Transfer Coefficient = Real %e\n"%(dirBC[3]))
                for spconc in dirBC[-1]:
                    stinds = _digit(inds+1)
                    stindb = str(dirBC[1])+stinds
                    sifFile.write("Boundary Condition %s\n"%stindb)
                    sifFile.write("  Target Boundaries (1) = %s\n"%str(dirBC[1]))

                    if (inds == 3):
#                        dirBC[3] = 2.e-3
                         pass
                    sifFile.write("  Mass Transfer Coefficient = Real %e\n"%(dirBC[3]))
#                    sifFile.write("  Mass Transfer Coefficient %s = Real %e\n"%(self.speciesNamesList[inds],dirBC[3]+inds))
#                    sifFile.write("  External Concentration %s = Real %e\n"%(self.speciesNamesList[inds],spconc))
#                    sifFile.write("  %s: External Concentration = Real %e\n"%(self.speciesNamesList[inds],spconc))
                    if (inds == 3 ):
                        sifFile.write("  External Concentration = Real %e\n"%(spconc))
                    else:
                        sifFile.write("  External Concentration = Real %e \n"%(0.))
                    
                    inds+=1
                    sifFile.write("End\n\n")
            elif (dirBC[2].lower()=="neumann"):
          ##
          ## Neumann boundary condition, for the moment, only a no flux boundary condition is treated
          ##
                stinds = _digit(inds)
                stindb = str(dirBC[1])+stinds
                sifFile.write("Boundary Condition %s\n"%stindb)
                sifFile.write("  Target Boundaries (1) = %s\n"%str(dirBC[1]))
                print " no flux neumann",
                for spconc in dirBC[-1]:
                    stinds = _digit(inds+1)
                    stindb = str(dirBC[1])+stinds
                    sifFile.write("  %s Flux = Real %e\n"%(self.speciesNamesList[inds],0.0))
                    inds+=1
            
                sifFile.write("End\n\n")
        return None

    def writeInitialCondition(self):
        sifFile = self.sifFile
        inds = 0        
        sifFile.write("! ~~\n! initial condition p8 ref. ElmersolverManual\n! ~~\n")
        for dirIC in self.dirICList:
            inds+=1
 #       for indb in range(len(self.bodies)):
 #           for inds in range(len(self.speciesNamesList)):
            sifFile.write("Initial Condition %s\n"%inds)
            ind = 0
            for spconc in dirIC[-1]:
                sifFile.write("  %s = Real %e\n"%(self.speciesNamesList[ind],spconc))
                ind+=1
            if (self.temperature==True):
                sifFile.write("  %s = Real %e\n"%("TEMPERATURE",25))
                pass
            sifFile.write("End\n")
                
        return None

    def writeSimulation(self):
        sifFile = self.sifFile
        sifFile.write("Simulation\n")
        sifFile.write("  Coordinate System = Cartesian "+self.mesh.getDimensionString()+"\n\n")
        sifFile.write("  Simulation Type = "+self.getSimulationType()+"\n")
#        sifFile.write("  Steady State Max Iterations ="+self.getSteadyStateMaxIter()+"\n\n")
        sifFile.write("  Coordinate Mapping(3) = 1 2 3\n")
        sifFile.write("  Timestepping Method = "+self.getTimeSteppingMethod()+"\n")
        if self.getTimeSteppingMethod() == "BDF":
            sifFile.write("  BDF Order = "+self.getBDFOrder()+"\n")
#            sifFile.write("  Newmark Beta 0.0\n\n")
        else:
            sifFile.write("  \n")
        # the following parameters are irrelevant, they are treated via the coupling algorithm    
        sifFile.write("  Timestep Sizes = 0.1\n")
        sifFile.write("  Timestep Intervals = 5\n\n")

        sifFile.write("  Output Intervals = 1\n")        
        sifFile.write("!  Lumped Mass Matrix = "+self.parameterDico["Lumped Mass Matrix"]+"\n")
        sifFile.write("  Max Output Level = 3\n")
        sifFile.write("End\n\n")
        return None
                
    def getGravityValue(self):
        return self.gravityValue
        
    def getGravityDirection(self):
        return self.gravityVector
        
    def end(self):
    
       self.essai.stop()
       return
        
    def getSimulationType(self):
        return self.simulationType
        
    def getSteadyStateMaxIter(self):
        return self.parameterDico["Steady State Max Iterations"]
	
    def getTimeSteppingMethod(self):
        return self.parameterDico["Timestepping Method"]
	
    def getBDFOrder(self):
        return self.parameterDico["BDF Order"]
	
    def initDomain(self,domainSpeciesAqueousConcentrations):
        if len(self.speciesNamesList) != len(domainSpeciesAqueousConcentrations):
            raise Exception(" problem within elmer with initialisation")
        self.essai(len(self.speciesNamesList),domainSpeciesAqueousConcentrations)

    def setDirBC(self,dirichletBoundaryCondition):
        #
        # used to set dirichlet boundary conditions
        #
        self.dirBCList.append(dirichletBoundaryCondition)
        return None

    def setFluxBC(self,fluxBoundaryCondition):
        #
        # used to set flux boundary conditions
        #
        self.dirBCList.append(fluxBoundaryCondition)
        return None

    def setNeuBC(self,dirichletBoundaryCondition):
        #
        # used to set dirichlet boundary conditions
        #
        self.dirBCList.append(dirichletBoundaryCondition)
        return None
        
    def setDirIC(self,initialCondition):
        self.dirICList.append(initialCondition)
        return None
        
    def setDarcyVelocity(self, darcyVelocity):
        """
        to set the Darcy velocity for elmer. A computed Darcy velocity must be inserted in the near future
        """
        norm = 0.
        for ind in darcyVelocity.getValue():
            norm += ind**2
        if norm>0: self.advConv = "Constant"
        self.darcyVelocity = darcyVelocity
        
    def setInitBody(self,initialisedBody):
        """
	an initial field is set overwritten, should be overwritten by concentration values
        """        
        self.initialisedBody = initialisedBody
	return None


    def setInstance(self, instance):
        """
	a control paramete of the instance
        """        
        print "  elmer dbg instance ",self.instance
        self.instance = instance
        return None

    def setMesh(self,  mesh):
        """
	to set or reset the name or the mesh
        """        
        self.mesh  = mesh
        return None

    def getMeshFileName(self):
        """
        to recover the name of the mesh file
        """        
        return self.meshFileName

    def setBoundaryConditionConcentrations(self, bCField):
        """
        set fields table of Concentration Boundary Condition (Dirichlet)
        """
	self.boundaryConditionConcDico["dirichlet"] = bCField
	print "setBoundaryConditionConcentrations ",bCField

    def setMeshFileName(self,  meshFileName="elmerMesh"):
        """
	to set or reset the name or the mesh
        """        
        self.meshFileName  = meshFileName
        return None
        
    def setProblemType(self,  problemType = "chemicaltransport"):
        self.problemType = problemType
    
       
    def setSifFile(self,sifFile):
        self.sifFile = sifFile
       
    def setTransportParameter(self, **solverparameterdict):

        for key, value in solverparameterdict.items():
            if key == "convSolver":
                self.parameterDico["Linear System Convergence Tolerance"] = value
            if key == "iterSolver":
                self.parameterDico["Linear System Max Iterations"] = value
            if key == "discretisation":
                self.parameterDico["discretisation"] = value
            if key == "algebraicResolution":
                self.parameterDico["algebraicResolution"] = value
            if key == "accelerator":
                self.parameterDico["Linear System Iterative Method"] = value
            if key == "preconditioner":
                self.parameterDico["Linear System Preconditioning"] = value
            if key == "timeSteppingMethod" or key == "tSM":
                self.parameterDico["Timestepping Method"] = value
            if key == "BDFOrder" or key == "BDFO":
                self.parameterDico["BDF Order"] = str(value)
            else:
                self.parameterDico["BDF Order"] = str(1)
            pass

    def defineElmerZones(self, field):
        """ 
	definition of zones for the elmer component
        """
        zonesList  = field.getZones()
        zoneNumber = 0
        for zone in zonesList:
            zoneNumber   += 1
            zoneName      = zone.getName()
            globalIndexes = zone.getGlobalIndexes()
            self.elmerZonesDico[zoneName] = (zoneNumber, globalIndexes)
            self.elmerNumberZoneDico[zoneNumber]=zoneName
            self.elmerZonesNamesList.append(zoneName)

        # zone-element connectivity, define zonePerCellDico
        for zoneName in self.elmerZonesNamesList:
            zoneNumber, globalIndexes = self.elmerZonesDico[zoneName] 
            for cell in globalIndexes:
                self.zonePerCellDico[cell] = zoneNumber
        return

    def advanceTime(self):
        """
        used to update time
        """
	if self.instance!=2:
	    self.essai.advanceTime()
	else:
	    self.essaig.advanceTime()
	return None
	
    def setTimeSteppingMethod(self,tSM):
        if type(tSM) is StringType:
            if tSM in ["Explicit Euler","BDF","Crank-Nicholson"]:
                self.parameterDico["Timestepping Method"] = tSM

    def setTimeStep(self,deltat):
        """
        used to update the time step
        """
	if self.instance!=2:
	    self.essai.dt(deltat)
	else:
	    self.essaig.dt(deltat)
	return None

    def getConcentrationValues(self):
        """
        used to transfer species concentrations from elmer to the coupling tool
        """
#	print " call of getConcentrationValues"
	if self.instance==2:
	    print " we get from the gas transport concentrations "
	    return self.essaig.getConcentration()
	else:   
	    return self.essai.getConcentration()

    def getCoordinatesValues(self):
        """
        
        Used to get coordinate values: return is a list of coordinates for node points
        
        """
#	print " call of getConcentrationValues"
#        coordinates = self.mesh.getNodesCoordinates()
	coordinates = self.essai.getCoordinates()
	elementsNumber = len(coordinates)/3
	listex = []
	listey = []
	listez = []
	for i in range(1,elementsNumber+1):
	    listex.append(coordinates[(i-1)*3])
	    listey.append(coordinates[(i-1)*3+1])
	    listez.append(coordinates[(i-1)*3+2])
	
	return [listex,listey,listez]

    def getTemperatureField(self):
        """
        used to transfer the temperature field from elmer to the coupling tool
        """
	return self.essai.getTemperatureField()
	    
    def majExpectedOutput(self):
        """ frequency treatment
        """
        # on retouche les temps de sortie au cas où il y a des frequency
        # pour les zones uniquement
        #print "self.outputs_zone['nom']",self.outputs_zone['nom']
        #print "self.calculationTimesDico['timespec']",self.calculationTimesDico['timespec']
        #print "self.calculationTimesDico['all_times']",self.calculationTimesDico['all_times']
##         if len(self.outputs_zone['nom']) == 0:
##             self.calculationTimesDico['timespec'] = [self.calculationTimesDico['final_time']]
##         else:
##             for output_name in self.outputs_zone['nom']:
##                 #print "self.outputs_zone['nom'],'timespec'",zone,self.outputs_zone['timespec']
##                 if self.outputs_zone.has_key('timespec'):
##                     for i in range(len(self.outputs_zone['timespec'])):
##                         timespec = self.outputs_zone['timespec'][i]
##                         print 'output_name,timespec',output_name,timespec
##                         if timespec.getSpecification() == 'frequency':
##                             f  = timespec.getFrequency()
##                             for j in range(0,len(self.calculationTimesDico['all_times']),f):
##                                 self.calculationTimesDico['timespec'].append(self.calculationTimesDico['all_times'][j])
##                                 pass
##                             pass
##                         pass
##                     pass
##                 pass
##             pass

        if self.outputs_zone['nom'] != []:
	    if not self.outputs_zone['nom']:
                self.calculationTimesDico['timespec'] = [self.calculationTimesDico['final_time']]
            else:
##             for output_name in self.outputs_zone['nom']:
##                 #print "self.outputs_zone['nom'],'timespec'",zone,self.outputs_zone['timespec']
                if self.outputs_zone.has_key('timespec'):
                    for i in range(len(self.outputs_zone['timespec'])):
                        timespec = self.outputs_zone['timespec'][i]
                        print 'output_name,timespec',self.outputs_zone['nom'][i],timespec
                        if timespec.getSpecification() == 'frequency':
                            f  = timespec.getFrequency()
                            for j in range(0,len(self.calculationTimesDico['all_times']),f):
                                self.calculationTimesDico['timespec'].append(self.calculationTimesDico['all_times'][j])
                                pass
                            pass
                        pass
                    pass
                pass

        if self.calculationTimesDico['timespec']:
            self.calculationTimesDico['timespec'].sort()
            #print "self.calculationTimesDico['timespec'] APRES",self.calculationTimesDico['timespec']
            self.calculationTimesDico['timespec'] = elimCommonElementsInList(self.calculationTimesDico['timespec'], 1E-15)
            #print "self.calculationTimesDico['timespec'] APRES2",self.calculationTimesDico['timespec']
            pass
        return

    def majStorageCoefficient(self):
        if self.problemType not in ['unknown','saturatedhydro','transienthydro',"chemicaltransport"]:
            raise Exception, " check the kind of problem you want to solve "
        print "self.problemType",self.problemType
        if self.problemType=='transienthydro':
            self.storageCoefficient=[]
            nbZones = len(self.porosT)
            if len(self.mat_comp)!=nbZones:
                msg='not same nbzones between porosity '+\
                     'and matrix compressibility factor ??'
                raise msg
            for zoneInd in range(nbZones):            
                tab=getTimeUnifiedTables(self.porosT[zoneInd],self.mat_comp[zoneInd])
                tnew=Table('Storativity')
                tnew.addColumn('time', tab[0].getColumn(0))
                print 'tab[0].getColumn(0)',type(tab[0].getColumn(0)),tab[0].getColumn(0)
                poro=list(tab[0].getColumn(1))
                mcf=list(tab[1].getColumn(1))
                stor=[self.density*self.absoluteGravity*(poro[i]*self.fluid_comp+mcf[i]) for i in range(len(poro))]
                tnew.addColumn('f(t)', stor)
                print 'poro,mcf,self.fluid_comp,stor',poro,mcf,self.fluid_comp,stor
                self.storageCoefficient.append(tnew)
                pass
            self.storageCoefficient=getTimeUnifiedTables(*tuple(self.storageCoefficient))
            self.nbStorageCoefficient=self.storageCoefficient[0].getNbRows()
            pass
        elif self.problemType=='saturatedhydro':
            self.nbStorageCoefficient=self.nbPoros
            pass
        elif self.problemType=='chemicaltransport':
            pass
        else:
            msg='Unknown Component : <%s>'%self.__class__.__name__
            raise msg
    def setHydraulicPorosityParameter(self,hpor):
        return None

    def init(self,studienName=None):
        """
	Used to launch the Elmer code:
		you set-up here all the file system 
		to launch elmer
        """
        self.timeDiscretizationTreatment()
        print "majStorageCoefficient"
        print "dbg elmer instance ",self.instance
        self.majStorageCoefficient()
##             pass
        #print " ic_n dbg ",studienName
	if self.instance!= None and self.instance!=2:
#	    self.name = "./Data/"+studienName + "_ctr"+str(self.instance)
	    self.name = "./Data/"+studienName + "_ctr"
	elif self.instance==2:
	    self.name = "./Datag/" + studienName + "_ctr"


        meshFileName = self.getMeshFileName()

        # Data directory creation 
        if not os.path.exists('Data') or not os.path.isdir('Data'):
            os.mkdir('Data')
            pass
	    
	if self.instance==2:
            if not os.path.exists('Datag') or not os.path.isdir('Datag'):
                os.mkdir('Datag')
	self.elmerStartInfo = open("ELMERSOLVER_STARTINFO","w")
	self.elmerStartInfo.write(self.sifFile)
	self.elmerStartInfo.close()
	
	print "dbg createSifFile"
        self.createSifFile()
	print "dbg createSifFile end",self.instance
	    
	if self.instance==0 or self.instance==1:
	    self.essai = WElmer
	    self.essai.initialize()
#	    self.essai.setInstance(self.instance)
	    print "ic_new dbg setSpeciesAnzahl: ",self.instance,self.unAnzahl,type(self.unAnzahl)
            print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            print " End of the elmer files writing phase"
            print "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
            pass
        return None
        
    def AqueousComponentOneTimeStep(self):
        """
        This method enables to solve one step in time for the aqueous equations
        """
        return self.essai.oneACTimeStep()
        
    def HeatOneTimeStep(self):
        """
        This method enables to solve one step in time for the heat equation
        """
        return self.essai.oneHTimeStep()

    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    def setCalculationTimes(self, calculationTimesList):
        """set calculation times
        """

        self.calculationTimesDico ['first_time'] = calculationTimesList[0]
        self.calculationTimesDico ['final_time'] = calculationTimesList[-1]
##         print "self.calculationTimesDico ['final_time']",self.calculationTimesDico ['final_time']
##         raise stop
        self.calculationTimesDico ['all_times']  = calculationTimesList

        # Determination du premier temps non nul
        t0 = calculationTimesList[0]
        if t0 != 0.0 :
            self.calculationTimesDico ['first_time_not_null'] = calculationTimesList[1]
        self.nbTimes = len(calculationTimesList)
	print " ic dbg self.nbTimes %i\n"%(self.nbTimes)
        return
    #----------------------------------------------------------
    #----------------------------------------------------------
    def setExpectedOutput(self, expected_output_dict_list_ini):
        """
	Set expected outputs
        """
	print "ic dbg Set expected outputs\n"
        expected_output_dict_list=\
           [eoDict.copy() for eoDict in expected_output_dict_list_ini]

        for eoDict in expected_output_dict_list:
            if (eoDict['quantity']=='TotalInflux') or ( eoDict['quantity']=='TotalFlux' and self.problemType=='extendedtransport' ):
                msg = '%s outputs not yet implemented.'%eoDict['quantity']
                raise Exception(msg)
            pass
        for eoDict in expected_output_dict_list:
            timespec=None
            OKtimespec='timespec' in eoDict.keys()
            if OKtimespec:timespec  = eoDict['timespec']
            if (not timespec) and OKtimespec:
                del eoDict['timespec']
                pass
##             print 'EXPECTED OUTPUT :\n',eoDict
            pass
            
        # times list of outputs
        if self.calculationTimesDico.has_key('first_time'):
            first_time = self.calculationTimesDico ['first_time']
        else:
            first_time = 0
            
        if self.calculationTimesDico.has_key('final_time'):
            final_time = self.calculationTimesDico ['final_time']
        else:
            final_time = 1
            
        eoTimesList = []
        eo_zone_TimesList = []
        for eoDict in expected_output_dict_list:
            timespec=None
            OKtimespec='timespec' in eoDict.keys()
            if OKtimespec:timespec  = eoDict['timespec']
##             if 'timespec' in eoDict.keys():
            if timespec:
                eoName    = eoDict['name']
##                 timespec  = eoDict['timespec']
                spec = timespec.getSpecification()
                if spec == 'times':
                    eoTimes = timespec.getTimes()
                    #print " 'times' eoTimes",eoTimes
                elif spec == 'period':
                    f  = timespec.getPeriod()
                    t  = first_time
                    ft = final_time 
                    eoTimes = [t]
                    while t < ft:
                        t += f
                        if t <= ft: eoTimes.append(t)
                    eoDict['timespec'] = TimeSpecification(times = eoTimes)
                    #print " 'period' eoTimes",eoTimes

                elif spec == 'frequency':
                    eoTimes = []  
                else:
                    raise AlliException('Other time specification has not been treated')

                eoTimesList += eoTimes
                #
                support = eoDict['support']
                if isinstance(support, MedSupport):eo_zone_TimesList+= eoTimes
                
            else:
                # il faut au moins un temps dans la liste des temps de sortie
                # pour l'hydro stationnaire
                eoTimesList=[0]
                eo_zone_TimesList=[0]
                pass
            pass

        if len(eo_zone_TimesList):
            eo_zone_TimesList.sort()
            eo_zone_TimesList = elimCommonElementsInList(eoTimesList, 1E-15)
            pass
        if len(eoTimesList):
            eoTimesList.sort()
            eoTimesList = elimCommonElementsInList(eoTimesList, 1E-15)
            pass
        self.expectedOutputDico['eoTimesList'] = eoTimesList

        if self.calculationTimesDico.has_key('timespec'):
            calculationTimes = self.calculationTimesDico['timespec'] + eoTimesList
        else:
            calculationTimes = eoTimesList
            pass
        #print 'eoTimesList',eoTimesList
        if calculationTimes:
            calculationTimes.sort()
            calculationTimes = elimCommonElementsInList(calculationTimes, 1E-15)
        self.calculationTimesDico['timespec'] = eo_zone_TimesList
        

        self.timespec=1
        
# <--- L.B.

        # for outputs
        self.outputs_point = None
        self.outputs_zone  = None
        self.outputs_surf  = None
        outpoint = []
        outzone  = []
        outsurf  = []
        
        for eoDict in expected_output_dict_list:
            support = eoDict['support']
            supportType =  support.__class__.__name__
            if   supportType in ["Point2D","Point3D","Point"]:    outpoint.append(eoDict)
            elif isinstance(support, MedSupport):                 outzone.append(eoDict)
            elif supportType =="tuple":                           outsurf.append(eoDict)
            pass
## ---> JG
        eoTimesJGLIST=[]
        for eoDict in outpoint+outsurf:
            OKtimespec='timespec' in eoDict.keys()
            if OKtimespec:timespec  = eoDict['timespec']
##             if 'timespec' in eoDict.keys():
            if timespec:
##                 timespec  = eoDict['timespec']
                spec = timespec.getSpecification()
                if spec == 'times':
                    eoTimesJGLIST.extend(timespec.getTimes())
                    pass
                pass
            pass
        if len(eoTimesJGLIST):
            eoTimesJGLIST.sort()
            eoTimesJGLIST=elimCommonElementsInList(eoTimesJGLIST, 1E-15)
            ideb=0
            while (eoTimesJGLIST[ideb]-first_time) < -1E-15:
                ideb+=1
                pass
            ifin=len(eoTimesJGLIST)
            while (eoTimesJGLIST[ifin-1]-final_time) > 1E-15:
                print 'eoTimesJGLIST[ifin-1],final_time',eoTimesJGLIST[ifin-1],final_time
                ifin-=1
                pass
            eoTimesJGLIST=eoTimesJGLIST[ideb:ifin]
            self.calculationTimesDico['all_times']=\
                     tableUnion(self.calculationTimesDico['all_times'],eoTimesJGLIST)
            pass

        # Traitement des differents types de support :
        if len(outpoint) != None:
	    nbCell    = len(outpoint)
	else:
	    nbCell    = 0
        if len(outsurf) != None:
            nbSurf    = len(outsurf)
	else:
            nbSurf    = 0
	
        nbZoneBil = len(outzone)

        # Points ...
        outCell       = []
        quantitePoint = []        
        nomPoint      = []
        supportPoint  = []        
        tempsPoint  = []        
        for pp in outpoint:
## --> JG  
            point=pp['support']
            #elem_index=getElementContainingPoint(list(point.getCoordinates() ),self.mesh)
            elem_index=getElementOnPoint(point.getCoordinates(),self.mesh) 
## <-- JG    
            supportPoint.append(pp['support'])
            outCell.append(elem_index)
            quantitePoint.append(pp['quantity'].upper())
            nomPoint.append(pp['name'])
            if 'timespec' in pp.keys():
                tempsPoint.append(pp['timespec'])
                pass
            pass

        nbFac        = []
        quantiteSurf = []
        nomSurf      = []
        supportSurf  = []
        globalInd    = []
        tempsSurf    = []
        for ss in outsurf:
            bboundary = ss['support'][0]
            nbFac.append( bboundary.getNbElements() )
            globalInd.append(bboundary.getGlobalIndexes())
            quantiteSurf.append(ss['quantity'].upper())
            nomSurf.append(ss['name'])
            supportSurf.append(ss['support'])
            if 'timespec' in ss.keys():
                tempsSurf.append(ss['timespec'])

        # Zones ...
        nbCellZone   = []
        cellZoneTemp = []
        quantiteZone = []
        nomZone      = []
        supportZone  = []
        where        = []
        tempsZone    = []
        for zz in outzone:
            print 'OUTPUT ZONE !',zz['name']
            #raise stop
            zzone = zz['support']
            supportZone.append(zzone)
            nbCellZone.append(zzone.getNbElements())
            cellZoneTemp.append(zzone.getGlobalIndexes())
            quantiteZone.append(zz['quantity'].upper())
            nomZone.append(zz['name'])
            if 'timespec' in zz.keys():
                tempsZone.append(zz['timespec'])
            # localisation de la sortie pour une zone : 'face' ou 'center' sont implementees
            if 'localisation' in zz.keys():
                if zz['localisation'] not in ['face','center']:
                    raise "Not Yet Implemented"
                else:
                    where.append(zz['localisation'])
            else:
                where.append('center')

        self.outputs_point = {'nbCell':nbCell,
                              'outCell' :outCell,
                              'quantite':quantitePoint,
                              'nom':nomPoint,
                              'support':supportPoint,
                              'timespec':tempsPoint}
        
        self.outputs_zone  = {'nbZoneBil':nbZoneBil,
                              'nbCellZone':nbCellZone,
                              'cellZoneTemp':cellZoneTemp,
                              'quantite':quantiteZone,
                              'nom':nomZone,
                              'support':supportZone,
                              'where':where,
                              'timespec':tempsZone}
        
        self.outputs_surf = {'nbSurf':nbSurf,
                             'nbFac':nbFac,
                             'quantite':quantiteSurf,
                             'nom':nomSurf,
                             'support':supportSurf,
                             'globalInd':globalInd,
                             'timespec':tempsSurf}

        return

    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    def timeDiscretizationTreatment(self):
        """ Once the user has given time discretization parameters,
        calculationtimes are changed for Traces (Imfs code).

        One must take care of ExpectedOutputs (EO) :
        - EO with a timespec in 'frequency' have to be changed
        in EO with timespec in 'times' with good dates.
        """
        #
        dico=self.parameterDico
        if not dico.has_key('timediscr') :
            self.setCalculationTimes([0.,1.])
            return
        timediscr=dico['timediscr']

        temps=self.calculationTimesDico ['all_times'][:]
        begin_time=temps[0]
        end_time=temps[-1]
        #
        for td in timediscr:
            li=td.getTimeInterval()
            tdeb,tfin=li[0],li[1]
            if tdeb<begin_time:tdeb=begin_time
            if tfin>end_time:tfin=end_time
            td.setTimeInterval([tdeb,tfin])
            pass

        newtemps=[]
        for i in range(len(temps)-1):
            period=temps[i+1]-temps[i]
            tdiscrOk=0
            for td in timediscr:
                try:
                    li=td.getTimeInterval()
                except:
                    end_time=self.calculations_times[-1]
                    li=(begin_time,end_time)
                    pass
                tdeb,tfin=li[0],li[1]

                espinol=1.e-6
                ttdeb=tdeb-abs(tfin-tdeb)*espinol
                ttfin=tfin+abs(tfin-tdeb)*espinol
                if ttdeb<=temps[i] and temps[i+1]<=ttfin:
                    td_good=td
                    tdiscrOk=1
                    break
                pass
            if not tdiscrOk:
                msg="\nLes intervalles de temps choisis pour la discretisation temporelle"
                msg+='\n(via le setParameter), de la forme [t_debut,t_fin], doivent '
                msg+='\netre en accord avec les instants passés au probleme (qui sont justement'
                msg+='\nles dates jalons prevues a cet effet. En clair, t_debut et t_fin'
                msg+='\nde chaque ImfsTimeDiscr doivent correspondre a des instants passes au probleme.'
                msg+='\n\nARRET !\n'
                raise _TimeException()
            td_good.adapt2period(tdeb,temps[i],temps[i+1])
            if i==0:newtemps.append(temps[i])
            newtemps+=td_good.getDatesList(temps[i],temps[i+1],interval='opened')
            newtemps.append(temps[i+1])
            pass
        self.setCalculationTimes(newtemps)

        return None

    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    def vtkMeshFile(self,mesh):
        """
	vtk representation in the legacy format of a mesh file with only
	one kind of element associated to the whole domain
        """
        self.vtkMeshFile = 'mesh.vtk'
 	self.file_mesh=open(self.vtkMeshFile,'w')
        self.file_mesh.write("%s\n"%("# vtk DataFile Version 2.0"))
        self.file_mesh.write("%s\n"%("vtk output"))
        self.file_mesh.write("%s\n"%("ASCII"))
        self.file_mesh.write("%s\n"%("DATASET UNSTRUCTURED_GRID")) 
	self.file_mesh.write("%s %i %s\n"%("POINTS",mesh.getNodesAnz(),"float "))
	dim = mesh.getSpaceDimensions()

	#
	# coordinates of nodal points
	#
	koordinaten = mesh.getNodesCoordinates()
	if (dim==2):
	
	    for i in range(0,len(koordinaten)):
	        self.file_mesh.write("%s %s %s\n"%(koordinaten[i][0],koordinaten[i][1],0.))
	elif (dim==3):	
	    for i in range(0,len(koordinaten)):
	        self.file_mesh.write("%e %e %e\n"%(koordinaten[i],koordinaten[i+1],koordinaten[i+2]))
	else:
	    raise " error in mesh dimension "

	endPunkten = mesh.getConnectivity()
	
	numberOfCells = len(endPunkten)

	gmshType, vtkTyp  = mesh.getType()
        print "dbg vtkTyp ",vtkTyp
        print "dbg gmshType ",gmshType
	tabellenlange = numberOfCells*(1+4)
        self.file_mesh.write("%s %i %i\n"%("CELLS",numberOfCells,tabellenlange))
	for zell in endPunkten:
	    ind = zell[2]+3
	    if (vtkTyp==5):
	        self.file_mesh.write("%i %i %i %i\n"%(3,\
		                                      zell[ind]-1, zell[ind+1]-1, zell[ind+2]-1))
 	    elif (vtkTyp==9):
 	        print "zell ",zell
 	        self.file_mesh.write("%i %i %i %i %i\n"%(4,\
		                                         zell[ind]-1, zell[ind+1]-1, zell[ind+2]-1, zell[ind+3]-1))
  	    elif (vtkTyp==12):	
	        self.file_mesh.write("%i %i %i %i %i %i %i %i %i\n"%(8,\
		                                         zell[ind]-1, zell[ind+1]-1, zell[ind+2]-1, zell[ind+3]-1,\
		                                         zell[ind+4]-1, zell[ind+5]-1, zell[ind+6]-1, zell[ind+7]-1))

        self.file_mesh.write("%s %i\n"%("CELL_TYPES",numberOfCells))
        print "dbg vtkTyp",vtkTyp,numberOfCells
	for i in range(0,numberOfCells):
	    if gmshType == 2:
	        cellTyp = 4
	    if gmshType == 3:
	        cellTyp = 5
	    elif gmshType == 4:
	        cellTyp = 9
            elif gmshType == 8:
		cellTyp = 12
	    self.file_mesh.write("%i\n"%(cellTyp))
        self.file_mesh.write("%s %i\n"%("CELL_DATA ",numberOfCells))
        self.file_mesh.write("%s \n"%("SCALARS material_values float\n"))
	
        self.file_mesh.write("%s \n"%("LOOKUP_TABLE default\n"))
	for i in range(0,numberOfCells):
	    self.file_mesh.write("%i\n"%(0))
	self.file_mesh.close()
	return None
    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------    
    def setAdditionalSourceValues(self,source):
        """
        Transfer of a concentration field to elmer. this corresponds to the source term necessary
	to the Picard algorithm. In the case of the chemistry coupling, this source term is issued
	from the variation of the solid phase.
	See the AdvectionDiffusion solver
        """
	self.essai.setSource(source)
	return None
	
    def setBodyList(self,bodies):
    
        """
        we give access of bodies list to elmer, bodies
        here are to be understood in the sense of the coupling algorithm
        """
        self.bodies = bodies
#        print bodies
#        print dir(bodies)
#        raw_input("bodies")
        return None
	
    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    def setConcentrationValues(self,concentrations):
        """
        Transfer of concentrations to elmer: two cases with or without temperature
        """
        if self.instance==0:
	    print " py setconcentration values for instance 0",self.instance,self.unAnzahl,len(concentrations)
	    self.essai.setConcentration(concentrations)
        elif self.instance==2:
	    print " type of self.unAnzahl for instance 2",self.instance,self.gunAnzahl
	    #self.essaig.setConcentration(concentrations,1,self.gunAnzahl)
        else:
	    #self.essai.setConcentrationValues(concentrations,1,self.unAnzahl-1)
	    pass
	return None
    #---------------------------------------------------------------------------
    #---------------------------------------------------------------------------
    def setDefaultParameters(self):
        """
	default parameter values for elmer, see the manual p 30
        """
        # Time Stepping Method can be either euler explicit, Crank Nicholson or BDF
        #self.parameterDico['Timestepping Method']      = "Explicit Euler"
        self.parameterDico['Timestepping Method']      = "BDF"
        # in the case where the scheme is a Crank Nicholson scheme
        # 0. explicit scheme
        # 1  fully implicit
        # Between 0 and 1 : weighted scheme, see Hirsch
        self.parameterDico['thetaScheme']    = Dico()
        self.parameterDico['thetaScheme'] ["ALL"] =  0

        # range from 1 to 5
        #self.parameterDico['BDF Order']                     = "5"
        # steady state
        #self.parameterDico['Steady State Max Iterations'] = "2"
        # the two following terms are array values, see the solver manual p. 30
        self.parameterDico['Timestep Intervals']            = "100"
        self.parameterDico['Timestep Sizes']                = "10."
        # see the round.sif file for that term, it enables a variable time step size definition         
        self.parameterDico['Timestep Function']             = "Real"
        self.parameterDico['Lumped Mass Matrix']            = False
        # number of unknowns at a single node, it must stay to 1                
        self.parameterDico['Variable DOFs']                 = 1
         #  is a string:        "Cartesian 1D", "Cartesian 2D", "Cartesian 3D", "Cylindric" 
        self.parameterDico['Coordinate System']             = "Cartesian 3D"
         # name of the default equation to be solved. It will change in the future du to porosity addition
        self.parameterDico['Equation']                      = "Advection Diffusion"
         # name of the unknown for the system to be solved
        self.parameterDico['Variable']                      = "CB"
        self.parameterDico["Procedure"]                     = "AdvectionDiffusionTimeStep" "AdvectionDiffusionTimeStepSolver"
        self.parameterDico['Simulation Type']               = "Transient"
        
        self.parameterDico["algebraicResolution"]                   = "Iterative"
        self.parameterDico['Linear System Solver']                  = "Iterative"
         # possible values are CG CGS BiCGStab TFQMR GMRES
        self.parameterDico['Linear System Iterative Method']        = "BiCGStab"
        self.parameterDico['Linear System Max Iterations']          = 200
        self.parameterDico['Linear System Convergence Tolerance']   = 1.0e-8
        self.parameterDico['Linear System Preconditioning']         = "ILU0"
        self.parameterDico['Linear System ILUT Tolerance']          = 1.0e-08
        self.parameterDico['Linear System Symmetric']               = "False"
        self.parameterDico['Lumped Mass Matrix']                    = "False"
         
        self.parameterDico['Optimize Bandwidth']       = "True"
         # can be useful to stabilize the solution procedure in a convection case
        self.parameterDico['Stabilize']                = "False"
         # used in case of cnvection, default value is True
        self.parameterDico['Bubbles']                  = "True"
        self.parameterDico['Mesh']                     = self.meshFileName
        self.parameterDico['Mesh Input File']          = self.meshFileName
#         self.parameterDico[]               = 1
         	
        return

    def setSorptionLaw(self):
        """
        is people ask for 
        """
        for spec in range(len(self.speciesNamesList)):
            specName = self.speciesNamesList[spec]
            self.sorptionLawDico[specName] = Dico()   
            self.sorptionLawDico[specName]['NOSORP'] =  None                 


        return
       
    def setSpeciesNames(self):
        """set species names
           speciesList :  contains a species list
           return a species names list
        """        
        self.speciesNamesList = []
        ind = 0
        for species in self.speciesList:
            print "dbg elmer species names ",ind,species.getName()
            self.speciesNamesList.append(species.getName().upper())
            ind+=1
        return None

    def setSpecies(self, speciesList):
        """
        used to specify species names to the transport tool.
        """

        self.nbSpecies        = len(speciesList)
        self.speciesList      = speciesList
        self.setSpeciesNames()

    def setTemperature(self):
        """
        Transfer of the temperature parameters to elmer.
        """
	self.temperature = True  
	return None

    def setTemperatureParameter(self,temperatureOption):
        """
        Transfer of the temperature parameters to elmer.
        """
	self.essai.setTemperatureOption(temperatureOption)   
	return None

    def setTemperatureField(self,temperatureField):
        """
        Transfer of the temperature field to elmer.
        """
	self.essai.setConcentrationValues(temperatureField,self.unAnzahl,self.unAnzahl)
	return None

    def setBodies(self,bodies):
    
        """
        we set a list of bodies to be handled by elmer
        """
        self.bodies = bodies

    def getBodies(self):
    
        """
        we get from elmer a bodies list
	
        """
        return self.bodies

    def setEffectiveDiffusion(self, fieldList):
        """
        Through that function, we set the effective diffusion over the domain
        for all species
        """
        print dir(fieldList[0]),self.speciesNamesList
        for specInd in range(len(self.speciesNamesList)):
            speciesName = self.speciesNamesList[0]
            field      = fieldList[0]
            values     = field.getValues()
            bodiesDico  = Dico()
            val      = values[0]
            bodiesDico["domain"] = (val)
            self.effectiveDiffusionDico[speciesName] = bodiesDico
        return
        
    def setPorosity(self, fieldList):
        """
        A porosity for all species is set, the porosity field 
        being valid over the domain, so as constructed, the porosity
        is affected to CB
        """
        for specInd in range(len(fieldList)):
            specieName = self.speciesNamesList[specInd]
            field      = fieldList[specInd]
            values     = field.getValues()
            print "dbg porosity dico setting",values
            self.porosityDico[specieName] = values
        return None

    def setPorosityValues(self,porosityfield):
        """
        sets the porosity to elmer
                       
        Input  : a porosity field, a scalar being associated to each mesh cell 
        """
        self.essai.setPorosityValues(porosityfield)
	print " im_n dbg setPorosityValues"
	return None
    
    def getPorosityValues(self):
        """
        This method is used to supply a porosity list to the chemistry code.
	For the moment, the porosity is set to one
        """
        porFieldValues = [1.0]*self.mesh.getElAnz()
        print self.mesh.getElAnz()
#	for body in self.getBodies():
#	    print dir(body)
#	    print body.getZone()
#	    print dir(body.getZone())
        
	for body in self.getBodies():
            porosityValue = body.material.getPorosity().value
	    print "porosityValue ",porosityValue
            for i in body.getZone().getElements():
                porFieldValues[i-1] = porosityValue
	return porFieldValues
    
    def setUnknownsNumber(self,unAnzahl):
        """
        Set the transported phase unknown number
        """
        self.unAnzahl = unAnzahl
	return None
	
    def writeEquation1(self):
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Equation p28 ref. Manual\n! ~~\n")        
        for ind in range(len(self.speciesNamesList)):
            sifFile.write("Equation %i\n"%(ind+1))
            sifFile.write("  Advection Diffusion Equation %s True\n"%self.speciesNamesList[ind])
            sifFile.write("  Convection %s\n"%self.advConv)
            sifFile.write("  Concentration Units = Absolute Mass\n")
               
        if self.temperature == None:
            sifFile.write("  ActiveSolvers(1) = 1\n")
        else:
            sifFile.write("  ActiveSolvers(2) = 1 2\n")
        sifFile.write("End\n\n")
        return None
        
    def writeMaterial1(self):
        """
        A loop over materials and species.
        Each material is associated to each species.
        The numbering is on three digits, two for the species, at least one for the region.
        For the moment, the material is independant of the species.
        """
       
        sifFile = self.sifFile
        sifFile.write("! ~~\n! Material p29 ref. Manual\n! ~~\n")        
        for inds in range(len(self.speciesNamesList)):
            for indb in range(len(self.bodies)):
                stinds = _digit(inds)
                stindb = str(indb+1)+stinds
                sifFile.write("Material %s\n"%(stindb))
                if self.advConv == "Constant":
                    v = self.darcyVelocity.getValue()
                    sifFile.write("  Convection velocity %e %e %e\n"%(v[0],v[1],v[2]))
                sifFile.write(" %s Diffusivity %15.10e\n"%(self.speciesNamesList[inds],\
                                  self.bodies[indb].getMaterial().getEffectiveDiffusion().value.value))
                
                sifFile.write(" %s Soret Diffusivity %15.10e\n"%(self.speciesNamesList[inds],\
                                  self.bodies[indb].getMaterial().getThermalConductivity().value.value))
                sifFile.write("End\n\n")
        return None

def _TimeException():	
    message = "look at the time discretisation, discrepancies exist\n"
    raise Exception, message
  
def _digit(ind):
    if ind < 8:
        return "0"+str(ind+1)
    else:
      return str(ind+1)  
    
    	

# -*- coding: utf-8 -*-
"""
    The file is used to build up the PhreeqC structure necessary to phreeqc 
    and to ensure communication within the splitting algorithm
"""
from chemistry import ActivityLaw,\
                      Bdot,\
                      Davies,\
                      DebyeHuckel,\
                      ExchangeBindingSpecies,\
                      MineralTotalConcentration,\
                      ReversibleKineticLaw,\
                      Salt,\
                      Species,\
                      SpecificAreaPerMole,\
                      SpecificAreaPerGram,\
                      SurfaceBindingSpecies,\
                      SurfaceMineralBindingSpecies,\
                      ToDissolveMineralTotalConcentration,\
		      WYMEKineticLaw
		      
from constant import epsFP

from exceptions import Warning

from generictools import isInstance

from math import floor

from os import system

import os

from PhysicalProperties import ElectricPotential,\
                               ReactionRate

from PhysicalQuantities import MolesAmount,\
                               PhysicalQuantity,\
			       Time
			     
from re import compile as recompile

from species import AqueousMasterSpecies,\
                    AqueousSecondarySpecies,\
                    MineralSecondarySpecies,\
                    SorbedSecondarySpecies,\
                    SorbingSiteMasterSpecies,\
                    SurfaceSecondarySpecies,\
                    SurfaceSiteMasterSpecies

from string import lower,upper

from sys import exit,path

from types import FloatType, IntType, NoneType, StringType



def molarMassStringEval(mineralName):
    """ 
    Enables to determine the molar mass:
    molarMassStringEval("SiO2") -> [('Si', 1.0), ('O', 2.0)]
    
    """
    print " string name of the species ",mineralName
#    raw_input()
    mineralString = mineralName[:]
    if mineralString.find(":")!=-1:
	#
	# Some elements entail ":", we extract it from the name
	# we search the occurence of : and work hereafter on two lists: is it necessary?
	#
	mineralString = [mineralName[0:mineralName.index(":")],mineralName[mineralName.index(":")+1:]]
        print " Warning in the evaluation of molar mass ",mineralString
    else:
        mineralString = [mineralName[:]]
	    
    elementList = []
    listOfSpecies = []
#    print " mineralString to be treated ",mineralString
    for character in mineralString:
        if len(character)!=0:
            elementList.append((character,1.))
	    
    #
    # the list of master species being established,
    # we treat it.
    #
    for element in elementList:
        elementName = element[0]
        lengthName = len(elementName)
        lange = 0
        while lange < lengthName:
            gewicht = element[1]
            digit = 1.0
            char = elementName[lange]
            if (lange<lengthName):
                if lange+1<lengthName:
                    if elementName[lange+1].isalpha():
                        if elementName[lange+1] != elementName[lange+1].upper():
                            char += elementName[lange+1]
                            lange += 2
                            if lange < lengthName:
                                if elementName[lange].isdigit():
                                    digit = digit*float(elementName[lange])
                                    lange += 1
                        else:
                            lange += 1
                            pass
                    elif elementName[lange+1].isdigit():
                        #
                        # if the element is made only of one character O, C, ...
                        #
                        #print "ionNumbering",elementName,elementName[lange+1:]
                        #raw_input()
                        ind,digit = ionNumbering(elementName[lange+1:])
                        #print ind,digit,elementName[lange+1:]
                        #raw_input()
                        lange += ind+1
                    else:
                        lange += 1
                else:
                    lange += 1
            listOfSpecies.append((char,float(gewicht)*float(digit)))
        ind = 0
        indBeg = 0
        indEnd = 0
        for species in listOfSpecies:
            if species[0] == '(':
                indBeg = ind 
            if species[0] == ')':
                indEnd = ind
                for indlist in  range(indBeg+1,indEnd):
                    coef = listOfSpecies[indlist][1]*listOfSpecies[indEnd][1]
                    listOfSpecies[indlist] = (listOfSpecies[indlist][0],coef)
            ind += 1
        ind = 0
        for char in listOfSpecies:
            if char[0] == '(' or char[0] == ')':
                del listOfSpecies[ind]
            ind+=1
    return listOfSpecies
    
def ionNumbering(element):
    """
    ionNumbering: used within the determination the molar mass
    """
    digital = ""
    ind = 0
    while element[ind].isdigit() or element[ind] ==".":
	digital += element[ind]
	if ind+1 == len(element): break
	ind += 1
    ind = len(digital)
    return ind,digital

def saltSpecies(saltSpeciesList,inFile):
    """ cf. the PhreeqC SOLUTION_MASTER_SPECIES keyword, used to define comonent unknowns
        The word primary is taken in the sense of the Yeh article
    """
    b0 = []
    b1 = []
    b2 = []
    c0 = []
    inFileWriter = inFile.write
    for salt in saltSpeciesList:
        if salt.b0: b0.append([salt.formationElements,salt.b0])
        if salt.b1: b1.append([salt.formationElements,salt.b1])
        if salt.b2: b2.append([salt.formationElements,salt.b2])
        if salt.c0: c0.append([salt.formationElements,salt.c0])
    if b0 != []:
       inFileWriter("b0\n")
       for couple in b0:
           _b0Writer(inFile,couple[0],couple[1])
    if b1 != []:
       inFileWriter("b1\n")
       for couple in b1:
           _b1Writer(inFile,couple[0],couple[1])
    if b2 != []:
       inFileWriter("b2\n")
       for couple in b2:
           _b2Writer(inFile,couple[0],couple[1])
    if c0 != []:
       inFileWriter("c0\n")
       for couple in c0:
           _c0Writer(inFile,couple[0],couple[1])
    
#          inFileWriter("%25s %10.5f%10s%10.5f\n"%(string,masterSpecies.alkalinity,masterSpecies.element,masterSpecies.molarMass.getValue()))
    return None

def solutionMasterSpecies(masterSpecies,inFile):
    """ cf. the PhreeqC SOLUTION_MASTER_SPECIES keyword, used to define comonent unknowns
        The word primary is taken in the sense of the Yeh article
    """
    string = masterSpecies.name+"   "+masterSpecies.symbol
    inFileWriter = inFile.write
    if not(masterSpecies.element):
        if not(masterSpecies.molarMass):
            form = "%25s %10.5f\n"
            inFileWriter(form%(string,masterSpecies.alkalinity))
        else:
            form = "%25s %10.5f%10.5f\n"
            inFileWriter(form%(string,masterSpecies.alkalinity,masterSpecies.molarMass.getValue()))
	return
    else:
        if not(masterSpecies.molarMass):
          form = "%25s %10.5f%10s\n"
          inFileWriter(form%(string,masterSpecies.alkalinity,masterSpecies.element))
        else:
          form = "%25s %10.5f%10s%10.5f\n"
          inFileWriter(form%(string,masterSpecies.alkalinity,masterSpecies.element,masterSpecies.molarMass.getValue()))
    return None

def solutionSpecies(spezien,inFile):

    """
    Secondary species reaction treatment
    """
    _formationReaction(0,inFile,spezien.formationReaction,spezien.symbol)
    
    _gamma(inFile,spezien)
	
    if (spezien.logK != None):
        _logKCoefWriter(inFile,spezien.logK)
    else:
        _logKWriter(inFile,spezien.logK25)
	pass
      
def sorbingSiteMaster(exchangeSite,inFile):
    """
    used to define exchange master species sites, see EXCHANGEMASTERSPECIES
    """
    form = "%10s%s\n"
    inFile.write(form%(" ",exchangeSite.name+"   " + exchangeSite.symbol))

def sorbedSpecies(sorbedSpezien,inFile):
    """
    used to define reactions in association with an exchange site
    """
    _reaction(inFile,sorbedSpezien.formationReaction,sorbedSpezien.symbol)
    
    _logKWriter(inFile,sorbedSpezien.logK25)

    inFileWriter = inFile.write

    _gamma(inFile,sorbedSpezien)
        
        
def surfaceSiteMaster(surfaceSite,inFile):
    """
    used to define exchange master species sites, see SURFACEMASTERSPECIES
    """
    form = "%10s%s\n"
    inFile.write(form%(" ",surfaceSite.name+"   " + surfaceSite.symbol))
    
def surfaceSpecies(spezien,inFile):
    """
    used to define reactions in association with a surface site
    """    
    _speciesFormationReaction(inFile,spezien.formationReaction,spezien.symbol)
    _logKWriter(inFile,spezien.logK25)
    return None

    
def mineralSpecies(mineral,inFile):
    """
    used to  treat Precipitation/Dissolution reactions
    """
    _formationReaction(1,inFile,mineral.formationReaction,mineral.symbol)

    if mineral.logK == None:
        _logKWriter(inFile,mineral.logK25)
    else:
        _logKCoefWriter(inFile,mineral.logK)

def aqueousSolution(state,iAnf,iEnd,inFile):
    """ 
    used to define each aqueous solution, through
    the SOLUTION keyword.
    """
    _keywordWriter(inFile,"SOLUTION",iAnf,iEnd,state.name)
    aqueousSol = state.aqueousSolution
    if aqueousSol.temperature == None:
        form = "   temp %15.10e\n"
        inFile.write(form%(25.0))
    else:
        form = "   temp %15.10e\n"
        inFile.write(form%(aqueousSol.temperature))
    if aqueousSol.pH != None:
        if state.charge == None:
            form = "   pH    %15.10e \n"
            inFile.write(form%(aqueousSol.pH))
	else:
            form = "   pH    %15.10e charge\n"
            inFile.write(form%(aqueousSol.pH))

    if aqueousSol.pe!=None:
        form = "   pe    %15.10e\n"
        inFile.write(form%(aqueousSol.pe))
    inFile.write("   units mol/l\n")
    
    for spezien in aqueousSol.elementConcentrations:
        #
        # converting to default unit
        #
        spezien.convertToUnit('mol/l')
        form = "%25s    %15.10e\n"
        inFile.write(form%(spezien.symbol,spezien.value))
#
# p. 151 of the phreeqC manual
#
# Indicates the concentration of this element will be adjusted to achieve charge balance. The element
# must have ionic species. If charge is specified for one element, it may not be specified for
# pH or any other element.
#
    if state.chargeBalance != None:
        form = "%25s    %15.10e charge \n"
        inFile.write(form%(state.chargeBalance[0],float(state.chargeBalance[1])))
    if state.mineralEquilibrium != None:
        for mineral in state.mineralEquilibrium:
            form = "%25s    %15.10e %25s \n"
            inFile.write(form%(mineral[0],mineral[2],mineral[1]))
#
#   Exchange species treatment
#  
    if state.ionicExchanger:
        _keywordWriter(inFile,"EXCHANGE",iAnf,iEnd,state.name)
        form = "               equilibrate   %5i\n"
        inFile.write(form%(iAnf))
        for spezien in state.ionicExchanger.exchangers:
	    if spezien.__class__ == ExchangeBindingSpecies:
                form = "%25s    %15.10e\n"
                inFile.write(form%(spezien.symbol,spezien.getExchangeAmount().getValue()))
	    elif spezien.__class__ == ExchangeMineralBindingSpecies:
                form = "%25s%20s equilibrium_phase    %15.10e\n"
                inFile.write(form%(spezien.symbol,spezien.mineral,\
                float(spezien.exchangePerMole)))
#
#   Surfaces species treatment
#    
    if state.surfaceComplexation and state.surfaceComplexation.surfaces != []:
        _keywordWriter(inFile,"SURFACE",iAnf,iEnd,state.name)
	form = "               equilibrate with solution %5i\n"
        inFile.write(form%(iAnf))
        for spezien in state.surfaceComplexation.surfaces:
	    if spezien.__class__ == SurfaceBindingSpecies:
	        if isinstance(spezien.specificAreaPerGram,SpecificAreaPerGram):
                    form = "%25s    %15.10e    %15.10e    %15.10e\n"
                    inFile.write(form%(spezien.name,\
		    spezien.getSites().getValue(),\
		    spezien.getSpecificAreaPerGram().getValue(),\
		    spezien.getMass().getValue()))
		else:
                    form = "%25s    %15.10e\n"
                    inFile.write(form%(spezien.name,spezien.getSites().getValue()))

	    if spezien.__class__ == SurfaceMineralBindingSpecies:
                form = "%25s%20s  equilibrium_phase  %15.10e    %15.10e\n"
                inFile.write(form%(spezien.symbol,spezien.mineral,\
		float(spezien.getSitesPerMole()),\
		spezien.getSpecificAreaPerMole().getValue()))

def mineralSolution(State,i1,i2,inFile,kineticLaws,gasOption):
    """
    To define mineral phases associated to an aqueous phase within a batch cell
    """
    boolean = 0
    mineralPhase = State.mineralPhase
    gasPhase = State.gasPhase
    phFixed = State.phFixed
    if gasPhase != [] or mineralPhase != [] or phFixed:
        try:
	    if kineticLaws == []:
	        if phFixed or gasPhase != []:
	            boolean = 1
	        pass
            if mineralPhase != [] and mineralPhase != None:
                for spezien in mineralPhase.minerals:
	            if kineticLaws == []:
		        boolean =1
		    for kineticLaw in kineticLaws:
		        if (spezien.symbol!=kineticLaw.symbol):
		            boolean = 1
		            pass
		        pass
            pass
        except Warning:
            print "##Warning: No mineral phase in contact with the aqueous phase within that solution"
        if (boolean == 1):
            _keywordWriter(inFile,"EQUILIBRIUM_PHASES",i1,i2,State.name)
	    try:
                if mineralPhase != [] and mineralPhase != None:
                    for spezien in mineralPhase.minerals:
		        test = 0
		        if kineticLaws != []:
		            for kineticLaw in kineticLaws:
		                if (spezien.symbol == kineticLaw.name):
			        #if spezien.value > 1.e-20:
			            test = 1
				    break
	                if (test == 0):
		            saturationIndex = 0.0
		            if spezien.__class__.__name__ in ["MineralTotalConcentration"]:
 		                saturationIndex = spezien.saturationIndex
		            elif spezien.__class__.__name__ in ["TotalConcentration"]:
 		                pass
			    else:
			        raise Exception, "the mineral total concentration instanciation has to be checked"
		            if spezien.__class__.__name__ in ["ToDissolveMineralTotalConcentration"]:
                                form = "%25s    %10.5e  %10.5e Dissolve_only\n"
                                inFile.write(form%(spezien.symbol,saturationIndex,spezien.value))
			    else:
                                form = "%25s    %10.5e  %10.5e\n"
                                inFile.write(form%(spezien.symbol,saturationIndex,spezien.value))
            except Warning:
                print "## Warning: No mineral phase for this solution"
        if (boolean == 1) and (gasOption == None):
            try:
                if gasPhase:
                    for spezien in gasPhase.gas:
                        form = "%25s    %10.5e  %10.5e\n"
                        inFile.write(form%(spezien.symbol,spezien.value,1.0))
            except Warning:
                print "# Warning: No gaz phase associated to this solution"		
            if phFixed:
                form = "%25s    %10.5e  %s	%10.5e\n"
                inFile.write(form%("Fix_H+",-1.0*State.aqueousSolution.pH,\
                phFixed[0],phFixed[1]))
	elif (boolean == 0):
            _keywordWriter(inFile,"EQUILIBRIUM_PHASES",i1,i2,State.name)
            try:
                if gasPhase:
                    for spezien in gasPhase.gas:
                        form = "%25s    %10.5e  %10.5e\n"
                        inFile.write(form%(spezien.symbol,spezien.value,1.0))
            except Warning:
                print "#Warning: No gas phase for this solution"
            if phFixed != None:
                form = "%25s    %10.5e  %s	%10.5e\n"
                inFile.write(form%("Fix_H+",-1.0*State.aqueousSolution.pH,\
                phFixed[0],phFixed[1]))
	    pass
    kineticbool = 1		
    if kineticLaws != []:
        try: 
            for spezien in mineralPhase.minerals:
                for kineticLaw in kineticLaws:
                    if isInstance(kineticLaw,ReversibleKineticLaw):
		        if (spezien.symbol == kineticLaw.symbol):
	                    if kineticbool == 1 :
                                _keywordWriter(inFile,"KINETICS",i1,i2,"")
				kineticbool = 0
                            form = "	%s\n"
                            inFile.write(form%(spezien.symbol))        
                            form = "	-m %15.10e %15.10e\n"
                            inFile.write(form%(spezien.value,spezien.value)) 
                            form = "	-parms %15.10e %15.10e %15.10e %15.10e\n"
                            inFile.write(form%( kineticLaw.specificSurfaceArea,\
			                        kineticLaw.sphereModelExponent,\
			                        kineticLaw.rate.value,kineticLaw.SRExponent))        
			    #inFile.write("	INCREMENTAL_REACTIONS true\n")
                    elif isInstance(kineticLaw,WYMEKineticLaw):
		        if (spezien.symbol == kineticLaw.name):
	                    if i1 == i2 and kineticbool == 1:
                                _keywordWriter(inFile,"KINETICS",i1,i1,"")
				kineticbool = 0
                            elif kineticbool == 1 :
                                _keywordWriter(inFile,"KINETICS",i1,i2,"")
				kineticbool = 0
                            form = "	%25s\n"
                            inFile.write(form%(kineticLaw.name))
                            form = " -m %15.10e  %15.10e \n"
                            inFile.write(form%(spezien.value,spezien.value)) 
                        #inFile.write(" -m %15.10e\n" %(spezien.value))
			    if (kineticLaw.rate.unit == "mol/m2/s") or (kineticLaw.rate.unit == ""):
			        parm1 = kineticLaw.rate.value
                            form = " -parms %15.10e %15.10e\n"
                            inFile.write(form%(parm1,kineticLaw.surface.value ))        
                            form = " -formula %s\n"
                            inFile.write(form%(kineticLaw.symbol))        
                            inFile.write(" -cvode true\n")        
                            inFile.write(" -tol 1.e-9\n")        
	    #inFile.write("	INCREMENTAL_REACTIONS true\n")
	    pass
		
        except Warning:
            print "## Warning: No kinetic law"
    else:
        print "## Warning: No kinetic law"
        
def solidSolution(solidSol,iAnf,iEnd,inFile, name = None):
    """ 
    	We treat solid solutions here, the solidSolution is of type solidsolution. See the chemical.py module
	
	example of the phreeqC SOLID SOLUTIONS keyword, cf. the manual page 144:
	
	 SOLID SOLUTIONS 1 Two solid solutions
	 	CaSrBaSO4 # greater than 2 components, ideal
		    -comp	Anhydrite	1.500
		    -comp	Celestite	0.05
		    -comp	Barite		0.05
		    
         SOLID_SOLUTION            1-1 Solid Solution of Strontianite and Aragonite
                Ca(x)Sr(1-x)CO3 	# binary, nonideal
                    -comp                 Aragonite             0.0E+00
                    -comp              Strontianite             0.0E+00
                    -temp              2.5E+01
                    -Gugg_nondim         0.0E+00         0.0E+00
    """
    if name == None: name = ""
    if type(iAnf) != IntType:
        raise TypeError, " the first indices must be an integer "
    if iEnd == None:
        _keywordWriter(inFile,"SOLID_SOLUTION",iAnf,iAnf,name)
    else:
        if iAnf < iEnd:
            _keywordWriter(inFile,"SOLID_SOLUTION",iAnf,iEnd,name)
	else:
            Warning(" verify the parameters bound of the SOLID SOLUTION keyword")
            _keywordWriter(inFile,"SOLID_SOLUTION",iEnd,iAnf,name)	
#
# Solid solution name treatment
#
    form = "%20s 		#ideal\n"
    inFile.write(form%(solidSol.name))
#
# Pure phase components within solid solution
#
    for purephase in solidSol.mineralAmounts:
        form = "%20s%25s    %15.10e\n"
        inFile.write(form%("-comp ",purephase.symbol,float(purephase.value)))
#
# Solid solution temperature
#
    if solidSol.temperature != None:
        form = "   %16s %15.10e\n"
        inFile.write(form%("-temp    ",solidSol.temperature))
    else:
        form = "  %16s %15.10e\n"
        inFile.write(form%("-temp    ",25.0))
    if solidSol.gugg != None:
        form = "   %23s %15.10e %15.10e\n"
        inFile.write(form%("-Gugg_nondim",solidSol.gugg[0],solidSol.gugg[1]))

    return None

def gasSolution(state,iAnf,iEnd,inFile):
    """ 
    	keyword GAS_PHASE, See the module chemistry.py
	
	
	example of the phreeqC input file issued from the manual, see p.91:
	
        GAS_PHASE 1-5 Air
             -fixed_pressure
             -pressure       1.0
             -volume         1.0
             -temperature    25.0
             CH4(g)          0.0
             CO2(g)          0.000316
             O2(g)           0.2
             N2(g)           0.78
    """
    _keywordWriter(inFile,"GAS_PHASE",iAnf,iEnd,state.name)

    inFile.write("        -fixed pressure\n"\
                 "        -pressure 1.0 # the pressure is set to the atmospheric pressure\n"\
                 "        -volume 1.0   # the volume is reaffected within the algorithm; warning\n")
#
# Gas solution temperature, default is 25 celcius degree
#
    if aqueousSol.temperature != None:
        form = "        temperature    %15.10e\n"
        inFile.write(form%(aqueousSol.temperature))
    else:
        form = "        temperature    %15.10e\n"
        inFile.write(form%(25.0))
#
# Gas phase primary species
#
    for gas in state.gasPhase.gas:
        form = "%25s    %10.5e\n"
        inFile.write(form%(gas.symbol,gas.value))

    return None
    
class Phreeqc:        
    """
    Phreeqc class used to enable driving of the tool, mainly, interaction between chemistry and transport  within
    the coupling algorithm. Parallelism is also covered.
    """

    def __init__(self,numberOfProcessors = None,rank = None):
        """
        geochemical solver
        """
        
	self.cellPorosity = None
	self.cellsNumber = 0
	self.chemicalParameters = []
	self.comment = ""
	self.initialPorosity = None
	self.inFile = None
	self.kineticLaws = []
	self.porosityOption = None
	print " phreeqc init method ",numberOfProcessors
	if (numberOfProcessors!=None):
	    self.mpiSize  = numberOfProcessors
            from WPhreeqc_mpi import *
	    self.solver = WPhreeqc_mpi()
	    self.solverFileName = "phreeqCFile"+str(rank)
	else:
	    self.numberOfProcessors = 1
	    self.mpiSize = 1
            from WPhreeqc import *
	    self.solver = WPhreeqc()
	    self.solverFileName = "phreeqCFile"
	    
	self.speciesBaseAddenda = []
#	self.solverFileName = "phreeqCFile"
	self.temperature = 0
	#
	#	gasOption:  two ways to treat a gas
	#		
	#       - using the GAS_PHASE treatment otherwise gasOPtion is let to None then the gas is treated 
	#               through the equilibrium_phase keyword 
	#	- None:	the gas is treated through the equilibrium_phase 
	#
	self.gasOption = None
	self.thermalOption = None
	self.mMolarMassList = []
	self.mVolumicMassList = []
	self.problemDensityList = []
	self.problemMineralList = []
	self.line = 1
#
# For a sequential process, mpiSize is <=1, otherwise for //ism, mpiSize is greater than one.
#	
#	self.mpiSize = 1
#
# confer to phreeqc reference manual 99-4259
#		
	self.solverqcKeywords = ['NAMED_EXPRESSIONS',\
				'LLNL_AQUEOUS_MODEL_PARAMETERS',\
				# p 79
			 	'EQUILIBRIUM_PHASES',\
			 	# p 82
			 	'EXCHANGE',\
			 	# p 87
			 	'EXCHANGE_MASTER_SPECIES',\
			 	# p 88
			 	'EXCHANGE_SPECIES',\
			 	# p 91
			 	'GAS_PHASE',\
			 	# p 106
			 	'KINETICS',\
			 	# p 111
			 	'KNOBS',\
			 	# p 118
			 	'PHASES',\
			 	# p 124
			 	'RATES',\
			 	# p 154
			 	'SOLUTION_MASTER_SPECIES',\
			 	# p 156
			 	'SOLUTION_SPECIES',\
			 	# p 169
			 	'SURFACE_MASTER_SPECIES',\
			 	# p 170
			 	'SURFACE_SPECIES']
        pass
    
    def getHelp(self):
        print self.__doc__
        pass
        
    def init(self,inFile,output,StatesBounds,trace,internal_nodes,chemicalParameters=None,\
    	     porosityOption=None,thermalOption = None):
        """ 
        Used to define the input files and write the data file
        """
	
        if chemicalParameters!=None:
	    self.chemicalParameters = chemicalParameters

	self.internalNodesNumber = internal_nodes
	self.cellPorosity = [1.0]*self.internalNodesNumber
	if StatesBounds != {} : 
            self.inFile = open(self.solverFileName,'w')
            self.dataSetup(StatesBounds)
	else:
	    print "="*20+"\n Warning : No state bound defined: eventually check your case file"+"="*20
	    print "self.solverFileName",self.solverFileName
	#print " pdbg init ",self.solverFileName,output
        self.defineInputOutput(self.solverFileName,output)
	#raw_input(" pdbg init ")
        self.solver.initialize(internal_nodes,self.mpiSize)
	#
	# porosity treatment: structure creation to treat the porosity variation
	#
        if self.porosityOption:
	    self.solver.porosityInitialisation(self.problemMineralList,self.mMolarVolumeList,len(self.problemMineralList))
	    pass
	return self.equilibrate("global")
        
    def setGasOption(self,gasOption = None):
        """ 
         Used to treat a gas phase through the GAS_PHASE keyword or in a standard way
        """
	if gasOption != None:
	    self.gasOption = gasOption	
	return None
        
    def setInternalCellsBeforeLaunching(self,intCellsBeforeLaunching):
	self.intCellsBeforeLaunching = intCellsBeforeLaunching
	return
	
    def getInternalCellsBeforeLaunching(self):
	return self.intCellsBeforeLaunching 
	
    def getPorosity(self,ind = None):
        """
	Used to get the porosity field
	from the chemistry and the fm0 for aqueousstateset
	
	"""
	epsilon = 1. + epsFP

        cellPorosity0 = self.solver.getPorosity()
	while epsilon > epsFP:
	    ind+=1

	    self.cellPorosity = self.solver.getPorosity()
	    for i in range(len(cellPorosity0)):
	        epsilon += abs(cellPorosity0[i] - self.cellPorosity[i])
	    epsilon/=len(cellPorosity0)	

	    self.cellPorosity0 = self.cellPorosity
	    self.solver.reactions(1,"internal")
	    self.cellPorosity = self.solver.getPorosity()
	self.solver.reactions(1,"internal")
	return self.cellPorosity

    def kinetics(self,kineticLaw):
        """ 
                Used to define user defined kinetic laws
                See the manual page 41 NUMERICAL METHOD AND RATE EXPRESSIONS FOR CHEMICAL KINETICS
                
                ReversibleKineticLaw
                
        """
        if isInstance(kineticLaw,ReversibleKineticLaw):
            mineral = kineticLaw.symbol
            self.inFile.write("%25s\n"%(mineral))
            self.inFile.write("\n-start\n")
            self.inFile.write("	1	rem M : currrent amount of moles\n")
            self.inFile.write("	2	rem M0 : initial amount of moles for %s\n"%(mineral))
            self.inFile.write("	3	rem PARM(1), PARM(2), PARM(3) and PARM(4) are the law parameters, see -parms under KINETICS\n")
            self.inFile.write("	4	rem PARM(1) : A/V, m2/l\n")
            self.inFile.write("	5	rem PARM(2) : M/M0 exponent\n")
            self.inFile.write("	6	rem PARM(3) : kinetic rate\n")
            self.inFile.write("	7	rem PARM(4) : exponent for SI\n")
            self.inFile.write("	10	sr_sh = SR(\"%s\")\n"%(mineral))
            #self.inFile.write("	20	if (M<= 0 and si_sh < 0) then goto 90\n")
            self.inFile.write("	30	t = 1.\n")
            self.inFile.write("	40	if M0 > 0 then t = M/M0\n")
            self.inFile.write("	50	if t = 0 then t = 1\n")
            self.inFile.write("	60	area = PARM(1)*(t)^PARM(2)\n")
            self.inFile.write("	70	rate = area*PARM(3)*(1.-sr_sh^PARM(4))\n")
            self.inFile.write("	71	rem print \"rate\" rate\n")
            self.inFile.write("	80	moles = rate*time\n")
            #self.inFile.write("	81	print \"rate\" rate \"moles\" moles time  \n")
            self.inFile.write("	90	SAVE moles\n")
            self.inFile.write("-end \n")
        elif isInstance(kineticLaw,WYMEKineticLaw):
            spezien = kineticLaw.name
            self.line = 1
            self.inFile.write("\n%25s\n\n"%(spezien))
            self.line+=1
            self.inFile.write("\n-start\n")
            self.inFile.write("	%s	rem M : current amount of moles\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	rem M0 : initial amount of moles for %s\n"%(self.line,spezien))
            self.line+=1
            self.inFile.write("	%s	rem PARM(1), PARM(2) represent a surface reaction and a kinetic rate\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	rem factor A0 and k0 of the law\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	ratew = 1.\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	ratey = 1.\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	ratem = 1.\n"%(self.line))
            self.line+=1
            self.inFile.write("	%s	ratee = 1.\n"%(self.line))
            ratew = "1"
            if kineticLaw.WTerm != None:
                ratew = ""
                for IonenListe in [kineticLaw.WTerm]:
                    for ion in IonenListe:
                       ratew += "ACT(\""+ion.symbol+"\")^"+ion.power.__str__()+"*"
                self.line += 1
                self.inFile.write("	%s	ratew = %s\n"%(self.line,ratew[:-1]))
            #
            # Y term 
            #
            self.line +=10
            ratey = "1"
            if kineticLaw.YTerm != None:
                rate_y = ""
                for Mineralien in kineticLaw.YTerm:
                    power1 = Mineralien.power1.__str__()
                    power2 = Mineralien.power2.__str__()
                    symbol = Mineralien.symbol

                    self.line+=10
                    aux = "SR(\""+Mineralien.symbol+"\")"
                    if abs(Mineralien.power1-1.0)>1.e-20:
		        aux = "("+aux+")^"+power1  
		    else:
		        aux = "("+aux+")"
                    self.line+=10
                    auy = "aux ="+aux
                    self.line+=10
                    self.inFile.write("	%s	%s\n"%(self.line,auy))
		    	  
                    if Mineralien.type == 'polynomial':
                        if kineticLaw.rate.value < 0 and kineticLaw.lawType == None :
                            auy = "aux = 1.-aux"
		    	    self.line+=10
                    	    self.inFile.write("	%s	%s\n"%(self.line,auy))
                            if abs(Mineralien.power2-1.0)>1.e-20:
                                rate_y = "(aux)^"+power2  
			    else:
                                rate_y = "aux"  
                        elif kineticLaw.rate.value > 0 and kineticLaw.lawType == None:
                            auy = "aux = 1.-aux"
		    	    self.line+=10
                    	    self.inFile.write("	%s	%s\n"%(self.line,auy))
                    	    auy = "if aux<0 then aux = 0"
		    	    self.line+=10
                    	    self.inFile.write("	%s	%s\n"%(self.line,auy))
                            if abs(Mineralien.power2-1.0)>1.e-20:
                                rate_y = "(aux)^"+power2
			    else:  
                                rate_y = "aux"
			elif kineticLaw.lawType == "reversible":
                            auy = "aux = 1.-aux"
		    	    self.line+=10
                    	    self.inFile.write("	%s	%s\n"%(self.line,auy))
                            if abs(Mineralien.power2-1.0)>1.e-20:
                                rate_y = "(aux)^"+power2
			    else:  
                                rate_y = "aux"

                    else:
                        aux = "LOG10("+aux+")"
                        if x.rate.value < 0:
                            if abs(Mineralien.power2-1.0)>1.e-20:
                                rate_y = "(aux)^"+power2
			    else:
                                rate_y = "aux"
                        else:
                            if abs(Mineralien.power2-1.0)>1.e-20:
                                rate_y = "(aux)^"+power2
			    else:  
                                rate_y = "aux"

                    self.line+=10
                    self.inFile.write("	%s	ratey = %s\n"%(self.line,rate_y))
                    self.line+=10
		    #aux = "if ratey > 0 then ratey = 0."
                    #self.inFile.write("	%s	%s\n"%(self.line,aux))
                    self.line+=10
		    print "pc Spezien ",spezien,type(spezien)
		        
            #
            # M term 
            #
            if kineticLaw.MTerm != None:
                for Spezien in kineticLaw.YTerm:
                    nenner = spezien.halfSat+"^"+spezien.power1+"MOL(\""+spezien.symbol+"\")^"+spezien.power1
                    rate_mi+= "(MOL(\""+spezien.symbol+"\")"+")/"+nenner+")^"+str(power2)
                    self.inFile.write("	%s	ratem = ratem*%s\n"%(self.line,rate_mi))
                pass
            #
            # E term 
            #
	    print x.ETerm
            if kineticLaw.ETerm != None:
                ratee = ""
                for Mineralien in kineticLaw.ETerm:
                    aux = "SR(\""+Mineralien.symbol+"\")"
                    self.line+=10
                    ratee+= "(1.- (1.- (SI(\""+Mineralien.symbol+"\"))^"+str(Mineralien.power1)+"))^"+str(Mineralien.power2)
                    self.line+=10
                    self.inFile.write("	%s	ratee = %s\n"%(self.line,ratee))
                pass

            self.line+=10
            #self.inFile.write("	%s	print ratey\n"%(self.line))
            self.line+=10
	    
            #npx auxx = "(1.- (SR(\""+Mineralien.symbol+"\")))"
            #name = "\""+Mineralien.symbol+"\""
            #self.inFile.write("	%s	aux = %s\n"%(self.line,auxx))
            #self.line+=10
            #name = "\""+Mineralien.symbol+"\""
            #self.inFile.write("	%s	name = %s\n"%(self.line,name))
            self.line+=10

            self.line+=10
            self.inFile.write("	%s	rate = .001*parm(1)*parm(2)*ratew*ratey*ratem*ratee\n"%(self.line))
            self.line+=10
            #self.inFile.write("	%s	moles = ((m/m0)^0.666)*rate*time\n"%(self.line))
            self.inFile.write("	%s	moles = rate*time\n"%(self.line))
#            self.line+=10
#            self.inFile.write("	%s	if abs(moles) < 1.e-15 then moles = 0.\n"%(self.line))
            self.line+=10
	    #aux = "if -moles > TOT(\""+spezien+"\") then moles = -tot(\""+spezien+"\""
	    #aux = "if -moles > M then moles = -M"
	    #aux = "if (moles > M) then moles = M"
	    #aux = "if M+moles < 0 then moles = M"
            #self.inFile.write("	%s     %s\n"%(self.line,aux))
            self.line+=10
            self.inFile.write("	%s	SAVE moles\n"%(self.line))
            self.inFile.write("-end\n")
            pass
        else:	
            raise Exception, "Wrong definition of the kinetic law type"
        return None

    def getCellPorosity(self,cell,ite):
        """
	porosity estimation within a cell
	"""
	if ite == 0:
	    cellPorosity = self.cellPorosity[cell]
	    newCellPorosity = self.solver.getCellPorosity(cell,0)
	    epsP = abs(1.0-newCellPorosity/cellPorosity)
	    ind = 0
#
# ind <2 to be considered as optimal.
#
	    while epsP > epsFP and ind<2:
	        self.solver.einzellequilibrium(cell)
	        cellPorosity = newCellPorosity
	        newCellPorosity = self.solver.getCellPorosity(cell,2)
		epsP = abs(1. - newCellPorosity/cellPorosity)
	        ind+=1
	    self.cellPorosity[cell] = newCellPorosity
        else:
	    self.cellPorosity[cell] = self.solver.getCellPorosity(cell,1)
	return None
##
    def modifyKineticLaws(self,kineticLaws,index=None):
        """
        This function is used to modify dynamically the properties of a kineticLaw.
        for the moment, it can't be modified to work on cells and it allows only to modify WYME laws.
        \param kineticLaws (List of KineticLaw or A KineticLaw) the Kinetic Law(s)
        to be modified
	\param [index] (list of integer) List of the cells concerned by this modfification
        """
        for kineticLaw in kineticLaws:
            name = kineticLaw.getName()
            if (name and self.dictKineticLaws.has_key(name)):
                if isInstance(kineticLaw,ReversibleKineticLaw):
		    mess = "only wyme laws can be modified for the moment"                    
                    raise mess
		elif isInstance(kineticLaw,WYMEKineticLaw):
                    kin =  self.defineWYMEKineticLaw(kineticLaw,self.dictKineticLaws[name])
                    if index:
                        return None
                    else:
			if (kineticLaw.rate.unit == "mol/m2/s") or (kineticLaw.rate.unit==""):
			    parm1 = kineticLaw.rate.value
                        self.solver.changeKinetics(kineticLaw.name,parm1,kineticLaw.surface.value)
                        pass
                    pass
                else:
                    raise TypeError, "the type of kinetic law is not supported for the moment"
                pass
            else:
                mess = "No name specified for this Kinetic Law or not existant Kinetic \
                law defined with this name. So impossible  to modified it"
                raise mess

        return 
	
        return None
	
    def getPorosityField(self,ite = None):
        if (ite == None):
   	    ite = 0
        for cell in range(self.internalNodesNumber):
   	    self.getCellPorosity(cell,ite)
   	return self.cellPorosity
	
    def getMolarMassList(self,URL):
        dataBaseFile = open (URL, 'r')    
        dbbPrimarysList = []
        dbbPrimarysMolarMassList = []
	

        while not dataBaseFile.readline().startswith("SOLUTION_MASTER_SPECIES"):
            pass
        non_whitespace=recompile('\S+')
        line=dataBaseFile.readline()
        while not line.startswith(" "):
            if not line.startswith("#"):
                match=non_whitespace.findall(line)
                if len(match)==5:
                    dbbPrimarysList.append(match[0])
                    dbbPrimarysMolarMassList.append(float(match[4]))
            line=dataBaseFile.readline()
	dataBaseFile.close()
	
        return 	dbbPrimarysList,dbbPrimarysMolarMassList
        
    def setMpiSize(self,mpiSize):
        self.mpiSize = mpiSize

    def setTimeStep(self,timeStep):
        """
        used to set the time step over which equilibrium is reached
	times is necessarly expressed in seconds for a  treatment within Phreeqc
        """
        if isInstance(timeStep,Time):
	    zeitInt = timeStep.inBaseUnits()
	    zeitInt = timeStep.getValue()
        else:
	    zeitInt = timeStep
        self.solver.setTimeStep(zeitInt)
	return None

    def setDataBase(self,name):
        """
        database to be emploied.
        """
        URL = os.path.splitext(name)[0] + '.dat'
        if not os.path.isabs(URL):
            URL = os.environ['PHREEQCDAT'] + "/" + URL
            pass
        self.solver.setDataBase(URL)
	self.elementList, self.molarMassList = self.getMolarMassList(URL)
	return None
	
    def setInitialPorosity(self,porosityField):
        """
        the initial porosity is set-up here, and then modified through the time dependant evolution
        of minerals within the system.
        """

        self.initialPorosity = porosityField
	cell = 0 
	for initialNodePorosity in self.initialPorosity:
            self.solver.setInitialNodePorosity(cell,initialNodePorosity)
	    cell+=1
	return None

    def setInitialNodePorosity(self, cell, cellInitialPorosityValue):
        """
        can be used to set-up the porosity on a specific cell 
        """
        self.solver.setInitialNodePorosity(cell,cellInitialPorosityValue)
	return None

    def setPorosity(self,porosityField):
        for porosity in range(len(porosityField)):
	    self.solver.setInitialNodePorosity(porosity,porosityField[porosity])
	return None
    
    def defineInputOutput(self, inFile, outFile):
        """
        used to set and open input and output files
        """
        print " pdbg inFile ",inFile
        print " pdbg outFile ",outFile
        self.solver.defineInputOutput(inFile, outFile)
	return None
    
    def getGasConcentrationValues(self):
        """
        to get gases concentrations list
        """
	return self.solver.getGasConcentration()
    
    def getGasUnknowns(self):
        """
        to get the gas unknowns list
        """
	return self.solver.getGasUnknowns()

    def setParameter(self, outFile):
        """
        method used to define the input and output file
        """
        print " phreeqc dbg setParameter ",self.solverFileName,outFile
	self.inFile = open(self.solverFileName,'w')
	StatesBounds = {}
	StatesBounds[self.chemicalState.name] = [[1,1],self.chemicalState]
        self.chemicalStateList = [self.chemicalState]
	self.dataSetup(StatesBounds)
	print " self.solverFileName",self.solverFileName
        self.solver.defineInputOutput(self.solverFileName, outFile)
	return None
	
    def setPhysic(self, parameter):
        """
        To set the physic to be treated, only temperature for the moment
        """
        if parameter.lower()=='temperature':
	    self.temperature = 1	
	return None

    def setStatesBounds(self,problem,StatesBounds,mesh = None):
        """
        Bounds determination for association to chemical states
        """
	chemicalStateList = []
	def StaatWahl(a,b):
	    return cmp(a[3],b[3])
	
	def StaatWahl1(a,b):
	    print a[3],b[3],a[1],b[1]
	    if a[3]==b[3]:
	        if a[1]>b[1]:
		    return 1
	        elif a[1]<b[1]:
		    return -1
	        elif a[1]==b[1]:
		    return 0
	    elif a[3]<b[3]:
	        return -1
	    else:
	        return +1

	def reorganise(brauchbar,nx):
	    liste = []
	    min_i1 = nx
	    for i in brauchbar:
	        min_i1 = min(min_i1,i[1])
	    for i in brauchbar:
	        j1 = i[3]
	        j2 = i[4]
	        if j1!=j2:
		    if i[1]==min_i1 and i[2]==nx:
		        liste.append(i)
		    else:
		        for j in range(j1,j2+1):
		            liste.append([i[0],i[1],i[2],j,j,i[-1]])
			    	    	
		else:
		    liste.append(i)
	    return liste
	#    	    	
	phreeqcchem = problem.name
	input=phreeqcchem
	ind = input.rfind(".")
	if (ind == -1): ind = len(input)
	output = input[0:ind]+".phout"
	self.nx = 0
	if problem.initialConditions!=[]:
	    print "dbg grid type ", problem.initialConditions[0].getZone().__class__.__name__
	    if problem.initialConditions[0].getZone().__class__.__name__!="CartesianMesh2D":
                                                                                                                #
                                                                                                                #    we treat elmer bodies
                                                                                                                #	
                listOfBoundaryPoints = []        
                for boundary in problem.boundaryConditions:
                    for node in mesh.getBody(boundary.boundary.getBodyName()).getBodyNodesList():
                        if node not in listOfBoundaryPoints:
                            listOfBoundaryPoints.append(node)
                
                kmin = 1000000
	        kboundary = 0
	                                                                                                        #
	                                                                                                        # We consider initial conditions using elmer
	                                                                                                        #
	        k1 = 0
	        for initialCondition in problem.initialConditions:
	            chemicalStateList.append(initialCondition.getValue())
	            anz = 0
	            nodesList = initialCondition.body.getBodyNodesList()
	            for node in nodesList:
	                if node not in listOfBoundaryPoints:
	                    anz+=1
	                    listOfBoundaryPoints.append(node)
	                
	            
		    anz = initialCondition.body.getNodesNumber()
		    print dir( initialCondition.body)
		    print initialCondition.body.bodyName," ic name ",initialCondition.value.name,anz
		    raw_input("~~~\nwithin statesbounds\n~~~")

		    k1 += 1      
                    StatesBounds[initialCondition.getValue().name+str(k1)] = [[kboundary+1,kboundary + anz],initialCondition.getValue()]
	            kboundary = kboundary + anz
#		    k1 = min(tempList)
#		    k2 = max(tempList)
#		    print "phreeqc dbg initial cond ",k1,k2,kboundary+1,kboundary + k2- k1 + 1
#		    if len(tempList) == k2 - k1 + 1:
#		        print "phreeqc dbg contigue ",kboundary+1,kboundary + k2 - k1 + 1
#                        StatesBounds[initialCondition.getValue().name+str(k1)] = [[kboundary+1,kboundary + k2 - k1 + 1],initialCondition.getValue()]
#			kboundary = kboundary + k2 - k1 + 1
#			print " value of kboundary ",k1,kboundary
#			print "                    "
#			print "                    "
#
# eventually enhance that part through examples to test it
#
#		    else:
#		        print "phreeqc dbg len list ",k1,k2,len(tempList),k2-k1+1
#		        tempList = initialCondition.zone.getElements()
		        
#		        print "dbg phreeqc tempList.sort",kboundary
#		        print tempList
#		        k1 = tempList[0]
#		        print "phreeqc dbg kboundary",k1,kboundary
#			ind = 0
#			for i in tempList:
#			    if i!=k1+ind:
#                                k2 = kboundary+ind
#				StatesBounds[initialCondition.getValue().name+str(k1)] = [[kboundary+1,k2],initialCondition.getValue()]
#				print " phreec dbg affectation ",kboundary+1,k2
#			        k1 = i
#			        kboundary = k2
#				ind=1
#			    else:
#			        ind+=1
#			if (ind!=1):
#			    StatesBounds[initialCondition.getValue().name+str(k1)] = [[kboundary+1,kboundary+ind],initialCondition.getValue()]
#		            print " phreec dbg out of loop affectation ",kboundary+1,kboundary+ind
#			    kboundary = kboundary+ind
	        print " phreeeqc dbg out of loop",kboundary
#		kmin = kmin - 1
                for stb in StatesBounds.keys():
                    StatesBounds[stb][0][0] = StatesBounds[stb][0][0]
                    StatesBounds[stb][0][1] = StatesBounds[stb][0][1]
                    
                print " phreeqc dbg states bound ",StatesBounds
		kboundary+=1
#		print "kboundary ",kboundary;raw_input("tata")
	        self.setInternalCellsBeforeLaunching(kboundary)

                for boundaryCondition in problem.boundaryConditions :
	            chemicalStateList.append(boundaryCondition.getValue())
		    k1 = kboundary
#                    print " phreeqc dbg states bound bc ",dir(boundaryCondition)
#                    print boundaryCondition.boundary.getBodyName()
                    StatesBounds[boundaryCondition.boundary.getBodyName()] = [[k1,k1],boundaryCondition.getValue()]
		    kboundary = kboundary+1
	        self.cellsNumber = kboundary-1	    
            else:
#
#    then for a cartesian like support, tested for the mt3d cartesian one
#	
	        for boundaryCondition in problem.boundaryConditions:
	            chemicalStateList.append(boundaryCondition.getValue())
                    for zones in boundaryCondition.boundary.zones:
	                self.nx = max(self.nx,zones.getIndexMax().i)
                for initialCondition in problem.initialConditions:
	            chemicalStateList.append(initialCondition.getValue())
                    for zones in initialCondition.zone.zones:
	                self.nx = max(self.nx,zones.getIndexMax().i)
	#	
                kboundary = 1
	

	        liste = []	        
	        brauchbar = []	        
                for initialCondition in problem.initialConditions:
                    for zones in initialCondition.zone.zones:
                        ind_min = zones.getIndexMin()
                        ind_max = zones.getIndexMax()
                        i1 = ind_min.i
                        i2 = ind_max.i
                        j1 = ind_min.j
                        j2 = ind_max.j
		
		        brauchbar.append([initialCondition.getValue().name,i1,i2,j1,j2,initialCondition.getValue()])
	
	        brauchbar = reorganise(brauchbar,self.nx)
	        brauchbar.sort(StaatWahl)
	        brauchbar.sort(StaatWahl1)
	
	        for initialCondition in brauchbar:
                    i1 = initialCondition[1]
	            i2 = initialCondition[2]
                    j1 = initialCondition[3]
                    j2 = initialCondition[4]
	            state = initialCondition[-1]
                    k1 = kboundary
                    k2 = kboundary+(j2-j1+1)*(i2-i1+1)-1
	            liste.append([[initialCondition[0]],k1,k2,state])
	            kboundary = k2+1
	
	        ind = 0
	        for i in liste:
	            chemicalstatelist = i[0][0]+"_"+str(ind)
	            StatesBounds[chemicalstatelist] = [[i[1],i[2]],i[-1]]
	            ind+=1
	
	        self.setInternalCellsBeforeLaunching(kboundary-1)

                for boundarycondition in problem.boundaryConditions :
	            ind+=1
                    for zones in boundarycondition.boundary.zones:
                        ind_min = zones.getIndexMin()
                        ind_max = zones.getIndexMax()
                        i1 = ind_min.i
                        i2 = ind_max.i
                        j1 = ind_min.j
                        j2 = ind_max.j
                        k2 = (j2-1)*(self.nx)+i2-1
                        k1 = kboundary
                        k2 = kboundary+(j2-j1+1)*(i2-i1+1)-1
                        StatesBounds[boundarycondition.getValue().name] = [[k1,k2],boundarycondition.getValue()]
		        kboundary = k2+1
	        self.cellsNumber = kboundary-1 	    
	else:
	    raise Exception, "Warning: You should define initial conditions within your problem" 
	    exit(0)
	return chemicalStateList
	
    def setChat(self,verbose):
        """
        Used to set verbose for phreeqC 
        """
        self.solver.defineVerbose(verbose)
	return None
	
    def getPrimarySpeciesNames(self):
        """
        to get chemical primary species names
        """
        return self.solver.getPrimarySpecies()
	
	
    def getChemicalUnknownNames(self):
        """
        To get the list of chemicals unknowns: chemical components +  ionic strength and activity of water.
        """
        return self.solver.getChemicalUnknowns()
	
    def getPrimarySpecies(self):
        """
        see getPrimarySpeciesNames
        """
        return [Species(component) for component in self.solver.getPrimarySpecies()]
	
    def getGasSpecies(self,gasList):
        """
        Initialization based on input and database files
        """
	return [Species(gas) for gas in gasList]
        
    def aqueousStateDump(self):
        """
        Used to restart from a previous state
        """
        return self.solver.aqueousStateDump()
        
    def getVolumeFraction(self):
        """
        Retrieve all species concentrations necessary to define
        PhreeqC states all over internal cells
        """
        return self.solver.getVolumeFraction()
        
    def aqueousStateSet(self,celltype):
        """
        That function gives access to previous defined states ( the dump method)
        It is used in conjunction with the iterative algorithm.
        """
        return self.solver.aqueousStateSet(celltype)
	
    def getChemicalZero(self):
        """
        Is used to retrieve from Phreeqc the chemical zero. Chemical values
	which are below are considered as zero
        """
        return self.solver.getChemicalZero()

    def getMobileConcentrationField(self,celltype=None):
        """
        Retrieve primaries concentrations fields from PhreeqC
	celltype can be either internal or boundary. Default is set to internal.
	No control is made over the celltype string, this string being set through a module.
        """       
        celltype = _zellTyp(celltype)

	if (self.mpiSize==1) or (celltype =='boundary'):    
            return self.solver.getMobileConcentration(celltype)
	else:
            return self.solver.getMobileConcentration_mpi(celltype)

    def getJacobian(self,cell):
        """
        Retrieve the jacobian to use within a CG method.
        """
        return self.solver.getJacobian(cell)

    def getPJacobian(self,cell):
        """
        Retrieve the jacobian defined by phreeqc for comparison
        """
        return self.solver.getPJacobian(cell)
	
    def getDebug(self,celltype=None):
        """
        primaries concentrations from PhreeqC over the whole mesh
        """
	celltype = _zellTyp(celltype)	    
        return self.solver.getMobileConcentration(celltype)
	
    def getTemperatureField(self):
        """
        to obain the temperature field
        """
        print "dbg phreeq getTemperatureField"
        return self.solver.getTemperatureField()
	
    def getTotalCO2Field(self):
        """
        to obain the total CO2 field
        """
        print "dbg phreeq getTotalCO2Field"
        return self.solver.getTotalCO2Field()	

    def getMobileConcentration(self,celltype=None):
        """
        primary species concentrations from PhreeqC over the whole mesh
        """
        celltype =  _zellTyp(celltype)
        return self.solver.getMobileConcentration(celltype)
        
    def getConc(self,concentration,componentList,length):
        """
        Retrieve solution concentration for each cell
        """
        return self.solver.getConc(concentration,componentList,length)
        
    def getDensity(self):
        """
        Retrieve water density for each cell
        """
        return self.solver.getDensity()
	
    def getExchangeMasterlist(self):
        """
        to get the sorption sites list
        """
        return self.solver.getExchangemasterlist()
	
    def getExchangeSpecies(self):
        """
        to get the sorbed species concentration list
        """
        return self.solver.getExchangespecies(ex_conc)

    def getExchangeSpecieslist(self):
        """
        to get the list of sorption species
        """

	#if (self.mpiSize==1) or (celltype =='boundary'):    
        #    return self.solver.getImmobileConcentration(celltype)
	#else:
        #    #return self.solver.getImmobileConcentration(celltype)
        return self.solver.getExchangespecieslist()

    def getImmobileConcentration(self,celltype=None):
        return self.solver.getImmobileConcentration('internal')
	
    def getImmobileConcentrationField(self,celltype=None):
        """
        Retrieve concentration 'fixed' for each cell
	
        Input : celltype ( string ) is set to internal	
        Output : a list of concentrations
		
        """
	celltype = _zellTyp(celltype)
	    
	if (self.mpiSize==1) or (celltype =='boundary'):    
            return self.solver.getImmobileConcentration(celltype)
	else:
            #return self.solver.getImmobileConcentration(celltype)
            return self.solver.getImmobileConcentration_mpi(celltype)
	    
    def getCellConcAtEqui(self,cell):
        """
        Used to handle boundary conditions,
        it enables to get aqueous concentrations
        at the equilibrium
        """
        return self.solver.getCellConcAtEqui(cell)

    def getCellTempAtEqui(self,cell):
        """
        Send back to python the temperature of the cell considered,
	usefull for a boundary condition treatment, the argument cell being an integer
        """
        return self.solver.getNodeEquiTemperature(cell)
        
    def getMWContent(self):
        """
        Retrieve solution concentration for each cell
        """
        return self.solver.getMWContent()

    def getNodeGasEquiConc(self, cell):
        """
        Send back to python the temperature of the cell considered,
	usefull for a boundary condition treatment, the argument cell being an integer	
        """
	return self.solver.getNodeGasConcentration(cell)

    def getAqueousStateprimaryConcentrations(self):
        """
        Send back to python a list of values for aqueous primary species,
	to be used for the boundary conditions. We have to retrieve concentrations 
	related to a single chemicalstate represented by cell 1.
        """
        return self.solver.getCellConcAtEqui(1)
	
    def getPurePhase(self,pp_conc):
        """
        Retrieve the complete list of pure phases from phreeqc.
	The list has been defined by the user.
        """
	
        return self.solver.getPurePhase(pp_conc)
	
    def getPurePhaseList(self):
        """
        To retrieve from PhreeqC the complete list of pure phases involved in the simulation
        """
        return self.solver.getPurePhaseList()
	
    def getPurePhaseAmount(self):
        """
        To retrieve the complete list of pure phases from phreeqc over the domain
	Every mineral of the system has an amount on each cell
	see also setPurePhaseAmount
        """
        return self.solver.getPurePhaseAmount()
        
    def getState(self,states,length_aqueous_comp,length_exchange_comp,length_purephase):
        """
        Used to get all informations necessary for the chemical state definition on a cell
        """
        return self.solver.getState(concentration)

    def getTotalConcentrationValues(self,celltype=None):
        """
        Retrieve concentration 'fixed' + 'aqueous' for each cell
	
	Input : type ( string ) is set to internal
		
	Output : a list of concentrations by primary species and cells [ C1_mesh, C2_mesh ]
        """
	celltype = _zellTyp(celltype)
	    
        return self.solver.getTotalConcentrationValues(celltype)
	
    def initialize(self,internalNodes):
        """
        Initialization based on input and database files
        """
        self.internalNodesNumber = internalNodes
        self.totalNodesNumber = self.solver.initialize(internalNodes,self.mpiSize)
	return 1
	
    def equilibrate(self,zellTyp=None):
        """
        to equilibrate the state cells
        default parameters for the reaction method are set to:
        ntime = 1
        time = 0.0
        """
        ntime = 1
        time = 0.0
#       self.solver.reactions(ntime,time)
        if (zellTyp==None):
	    zellTyp = "internal"
	else:
	    zellTyp = "global"
	if (self.mpiSize==1):    
            self.solver.reactions(1,zellTyp)
	else:
            self.solver.reactions_mpi(1)
	return 1
	
    def equilibrate_slave(self,zellTyp=None):
        """
        Permits the equilibrium simulation
        default parameters for the reaction method are set to:
        ntime = 1
        time = 0.0
        """
        ntime = 1
        time = 0.0
#       self.solver.reactions(ntime,time)
        if (zellTyp==None):
	    zellTyp = "internal"
	else:
	    zellTyp = "global"
        self.solver.reactions(1,zellTyp)
	return None

    def einzellequilibrium(self,cell):
        """
        To equilibrate a state cell :"""
        print "one cell equilibrium"*100
        self.solver.einzellequilibrium(cell)

    def run(self):
        """To equilibrate a single state cell"""
        self.solver.initialize(1,self.mpiSize)
        self.solver.einzellequilibrium(1)

    def getAllOutput(self):
        """
        Permits to retrieve from PhreeqC the information previously defined by the user
        """
        return  self.solver.getOutputAll()
 
    def getOutput(self,name,outputType=None,anf=None,end=None,unit=None):
    
        """
        Permits to retrieve from PhreeqC the information on a physical quantity named by name
	It retrieves for the unknown considered a list of floats associated to each mesh point
	
	Input : 
	
	name (string) : name of the ouput to retrieve
	type (string) : indicates the type of cell considered : for the moment only internal cells are considered
	anf, output_indice_2 (integers) : mesh indices where to retrieve the physical unknowns
	
	The default unit for the outputs is molality: mol/l
	
        """
	if name=="Concentration_mass_water": name = "Concentration_watermass"
	
	name = name.replace('Concentration_','')
	if (unit==None):
	    self.unit = "mol/l"
	elif (unit.lower()=="molal"):
	    self.unit = unit
	else:
	    self.unit = "mol/l"
	    
	string = str.find(name,"_")
	
	if (string==-1):
	    self.outputname = name
	else:
	    self.outputname = name[0:str.find(name,"_")]
	    pass
	
        if not(outputType):
            outputType = 'internal'
	    pass
	    
        if not(anf):
            anf = 0
            end = self.internalNodesNumber
	    pass
	    
        if (outputType=='internal'):
	    indA = 0
	    indE = self.internalNodesNumber	
        elif (outputType=='boundary'):
            indA = self.internalNodesNumber
            indE = self.internalNodesNumber+self.boundaryNodesNumber
        elif (outputType=='source'):
            indA = self.internalNodesNumber+self.boundaryNodesNumber
            indE = self.internalNodesNumber+self.boundaryNodesNumber+self.sourceNodesNumber
        else:
            raise Exception, "bad type for getOutput %s"%(outputType)
	    pass
	if  self.outputname.lower() == 'porosity':
	    self.outputname = 'porosity'
	if (self.mpiSize==1) :    
            liste = self.solver.getSelectedOutput(indA,indE,self.outputname,self.unit)
	    return liste
	else:
	    # only for nternal cells
            liste = self.solver.getSelectedOutput_mpi(indA,self.internalNodesNumber,self.outputname,self.unit)
	    
            if len(liste)>1: return liste
	
    def getOutputState(self):
        """
        Used to get the following elements:
               number_of_aqueous_primary_species
               number_of_aqueous_secondary_species
               number_of_sorbeb_species
               number_of_minerals               
               ph
	       pe
	       activityofwater
	       ionicstrength
               temperature
               electrical_balance
	       total_h
	       total_o
	       and a list of tuples representing the aqueous and mineral state
        """
        return  self.solver.getOutputState()
	
    def outputStateSaving(self):
        """
        Used to save within a file the following elements:
               number_of_aqueous_primary_species
               number_of_aqueous_secondary_species
               number_of_sorbeb_species
               number_of_minerals               
               ph
	       pe
	       activityofwatergetOutputState
	       ionicstrength
               temperature
               electrical_balance
	       total_h
	       total_o
	       and a list of tuples representing the aqueous and mineral state
        """
        state = self.solver.getOutputState()
        print type(state)
        outFile = open("phreeqCFile.out", 'w')
        for i in state:
            outFile.write("%s"%str(i))

    def setActivityLaw(self,activityLaw = None):
        """
        To determine which activity law will be used, the default one being Davies.
        """

        if isInstance(activityLaw,Davies):
            self.activityLaw = 'davies'
        elif isInstance(activityLaw,DebyeHuckel):
            self.activityLaw = 'debye-huckel'
        elif isInstance(activityLaw,Bdot):
            self.activityLaw = 'b-dot'
        else:
            self.activityLaw = 'davies'
        pass
    
    def phiBalance(self):
        return "residual ",self.solver.phibalance()

    def setChemicalState(self,chemicalState):
        """
        In the case of an equilibrium study for
        a non dimensional case, you use that method normally
        followed by a call to get its equilibrium.
        no cell numbering, having just one to be defined
        """
        self.internalNodesNumber = 1
	self.chemicalState = chemicalState
        self.phreeqC = Phreeqc()
	
    def setComment(self,comment = None):
        """
        Calling that method enables the introduction of any comment within the 
        phreeqC command file
        """
 	if type(comment) == StringType:
	    self.inFile = open(self.solverFileName,'a')
	    self.inFile.write(comment)
	    self.inFile.close()
	pass
	
    def setChemicalStates(self,internal,boundaries=None,sources=None):
        """
        Sets the permutation between phreeqc and the mt3d transport
        
        Input 
          internal  indices list of internal cells
          boudaries indices list of boundary cells
          sources   to define
        """

        # internal cells 
        self.internalNodesNumber = len(internal)

        # boundary cells
        if (boundaries!=None):
            self.boundaryNodesNumber = len(boundaries)
        else:    
            self.boundaryNodesNumber = 0

        # source cells 
        self.sourceNodesNumber = 0
                   
        return None

    def setMobileConcentrationValues(self,celltype,concentration_list):
        """
        used to set Concentrations to PhreeqC, A list of species other 
	the mesh :  [Cb over the mesh, TH over the mesh, TO over the mesh, Na over the mesh..]
        """
        self.solver.setMobileConcentrationValues(celltype,concentration_list)

    def setGasConcentrationValues(self,celltype,concentration_list):
        """
        used to set Concentrations to PhreeqC, A list of species other 
	the mesh :  cf. setMobileConcentrationValues
        """
	self.solver.setGasConcentrationValues(celltype,concentration_list)

    def setExpectedOutputs(self,expectedOutputs):
        """
        Fixes the expected outputs

        Input 
        ComputedOutputs : 
        list of (parameter,unit) or parameter if
        no unit  needed (ex pH)
        parameter (str) : name of the output
        unit (str) : unit of the output
        """
        self.dictOutputs = {}
        indexOutputs = 0
        for expectedOutput in expectedOutputs:
            self.dictOutputs[expectedOutput.getName()] = indexOutputs
            indexOutputs += 1
            pass
        return

    def molarMassEvaluation(self,spezien):
        """
	This function is used to evaluate the molar mass
	"""
        liste = molarMassStringEval(spezien.symbol)
	molarMass = 0.
	for i in liste:
	    molarMass +=self.molarMassList[self.elementList.index(i[0])]*i[1]
        return molarMass
	
    def setKineticLaws(self,kineticLaws):
        """ 
	List of kinetic laws to be brought in the data model
	"""
	self.kineticLaws = kineticLaws

    def setSpeciesBaseAddenda(self,speciesBaseAddenda):
        """ 
	List of new species to be brought in the data model
	"""
        for spezien in speciesBaseAddenda:
            if not isinstance(spezien, Species) and not isinstance(spezien, Salt):
                raise Exception, " not all elements of the speciesBaseAddenda are Species or Salt instances"
        self.speciesBaseAddenda=speciesBaseAddenda
	
    def setChemicalStateList(self,chemicalStateList, porosityOption = None, temperatureOption = None):
        """ 
	That function is used to determine the list of minerals being used within
	the list of chemical states to be treated. It returns a list of minerals: problemMineralList
	For densities, a default value of 2000 is defined
	For thermalConductivity, a default value of 0.6 W/m is defined
	"""
        self.porosityOption = porosityOption
        self.chemicalStateList=chemicalStateList
	self.setSolverPorosityOption(self.porosityOption)
        self.temperature = temperatureOption
	if (self.porosityOption or self.thermalOption):
	    for spezien in self.speciesBaseAddenda:
	        if (isinstance(spezien,AqueousMasterSpecies)):
		    if spezien.molarMass:
			if spezien.molarMass.unit.name() == 'kg/mol':
#			    self.molarMassList.append(spezien.molarMass.value*1000)
			    self.molarMassList.append(spezien.molarMass.value)
			elif spezien.molarMass.unit.name() == 'g/mol':   
#	                    self.molarMassList.append(spezien.molarMass.value)
	                    self.molarMassList.append(spezien.molarMass.value*0.001)
			name = spezien.name[:]
			if name =='CO3-2':
			    name = "C"
			name = name.replace("-","")
			name = name.replace('+','')
	                self.elementList.append(name)
	    #
	    # Now, I have to retrieve the molar mass of each mineralist element
	    #
	    #print " p dbg  length of self.chemicalStateList",len(self.chemicalStateList)
	    #raw_input()
	    for cs in self.chemicalStateList:
	        if cs.mineralPhase != None:
	            for mineral in cs.mineralPhase.minerals:
	                if mineral.symbol not in self.problemMineralList:
	     	            self.problemMineralList.append(mineral.symbol)
	    self.problemMineralList.sort()
	    #print " p dbg ",self.problemMineralList
	    #raw_input()
	    ind = 0
	    #
	    # Volumic mass
	    #
	    # the volumic mass (density) is set by default to 2000 kg/m**3 cf. PhysicalQuantities.
	    #
	    self.mVolumicMassList = [2000.]*len(self.problemMineralList)
	    #
	    # ThermalConductivity
	    #
	    # the default thermal conductivity value is the thermal conductivity value of water.
	    #
	    self.thermalConductivityList = [0.6]*len(self.problemMineralList)
	    self.mMolarMassList = [0.]*len(self.problemMineralList)
	    for spezien in self.speciesBaseAddenda:
		if isinstance(spezien,MineralSecondarySpecies):
		    if spezien.density:
			ind = self.problemMineralList.index(spezien.name)
		        self.mVolumicMassList[ind] = spezien.density.value
		    if spezien.thermalConductivity != None:
			ind = self.problemMineralList.index(spezien.name)
		        self.thermalConductivityList[ind] = spezien.thermalConductivity.value

		    if spezien.name.rfind("(g)")==-1 and spezien.name.rfind("Fix")==-1:
		        if spezien.name in self.problemMineralList:
			    ind = self.problemMineralList.index(spezien.name)
			    self.mMolarMassList[ind] = self.molarMassEvaluation(spezien)
		    
	    ind = 0
	    self.mMolarVolumeList = []
	    for minerals in self.problemMineralList:
		self.mMolarVolumeList.append(self.mMolarMassList[ind]/self.mVolumicMassList[ind])
	        ind+=1
	    pass

    def dataSetup(self,StatesBounds):
        """
        first, introduction of the different keywords to allow the update of the database
        then, keyword treatment
        """
        boolean_kinetics = 0
	
	if self.chemicalParameters!=[]:
	   for chemicalParameter in self.chemicalParameters:
	       self.inFile.write(chemicalParameter)
	       
	amsList = []
	assList = []
	mssList = []
	saltList= []
	ssmsList= []
	sssList = []
	ssList  = []
	ssmList = []
        for spezien in self.speciesBaseAddenda:
	
	    if isinstance(spezien,AqueousMasterSpecies):
                amsList.append(spezien)

	    elif isinstance(spezien,AqueousSecondarySpecies):
                assList.append(spezien)

	    elif isinstance(spezien,MineralSecondarySpecies):
                mssList.append(spezien)

	    elif isinstance(spezien,Salt):
                saltList.append(spezien)
		   
	    elif isinstance(spezien,SorbingSiteMasterSpecies):
                ssmsList.append(spezien)
		   
	    elif isinstance(spezien,SorbedSecondarySpecies):
		sssList.append(spezien)
		
	    elif isinstance(spezien,SurfaceSecondarySpecies):
		ssList.append(spezien)
		
	    elif isinstance(spezien,SurfaceSiteMasterSpecies):	    
		ssmList.append(spezien)
		
	if len(amsList) !=0: self.inFile.write("SOLUTION_MASTER_SPECIES\n")
        for spezien in amsList:
            solutionMasterSpecies(spezien,self.inFile)
                
	if len(assList) !=0: self.inFile.write("SOLUTION_SPECIES\n")
        for spezien in assList:
            solutionSpecies(spezien,self.inFile)
		
	if len(mssList) !=0: self.inFile.write("PHASES\n")
        for spezien in mssList:
            self.inFile.write("      %s\n"%(spezien.name))
            mineralSpecies(spezien,self.inFile)
		
	if len(saltList) !=0: self.inFile.write("PITZER\n")
        saltSpecies(saltList,self.inFile)
	    
	if len(ssmsList) !=0: self.inFile.write("EXCHANGE_MASTER_SPECIES\n")
        for spezien in ssmsList:
                sorbingSiteMaster(spezien,self.inFile)
		
	if len(sssList) !=0: self.inFile.write("EXCHANGE_SPECIES\n")
        for spezien in sssList:
            sorbedSpecies(spezien,self.inFile)

	if len(ssList) !=0: self.inFile.write("SURFACE_SPECIES\n")
        for spezien in ssList:
            surfaceSpecies(spezien,self.inFile)

	if len(ssmList) !=0: self.inFile.write("SURFACE_MASTER_SPECIES\n")
        for spezien in ssmList:
            surfaceSiteMaster(spezien,self.inFile)
        		
        if self.kineticLaws==None:
	    self.kineticLaws = []
	    pass
	elif self.kineticLaws != []:
	    for kineticLaw in self.kineticLaws:
	        if boolean_kinetics==0:
	            self.inFile.write("RATES\n")
		    boolean_kinetics=1
		self.kinetics(kineticLaw)
	        pass
	    
	for stateBound in StatesBounds.items():

	    Staat = stateBound[1][1]
	    print Staat.name
	    print stateBound[1][0]
	    dir(Staat)
	    raw_input("staat")
	    
            gA = stateBound[1][0][0]            
            gE = stateBound[1][0][1]
            aqueousSolution(Staat,gA,gE,self.inFile)

            if Staat.solidSolution != None and Staat.solidSolution != []:
	        solidSolution(Staat.solidSolution,gA,gE,self.inFile,Staat.name)

            if self.gasOption == None:
	        if Staat.mineralPhase or Staat.gasPhase:
                    mineralSolution(Staat,gA,gE,self.inFile,self.kineticLaws,self.gasOption)
	    else:
	        if Staat.mineralPhase:
                    mineralSolution(Staat,gA,gE,self.inFile,self.kineticLaws,self.gasOption)
	        if Staat.gasPhase:
                    gasSolution(Staat,gA,gE,self.inFile)
	        
	    pass
        self.inFile.write("SELECTED_OUTPUT\n  -high_precision true\n")
        self.inFile.write("KNOBS\n  -iterations 500\n  -diag true \n  -tolerance 1.e-15\n")
	
        self.inFile.write("SOLUTION 0\n")

        if self.cellsNumber == 1:
	    self.inFile.write("SOLUTION 2\n")

        self.inFile.write("PRINT\n  -reset	true\n"\
        "# hereafter the -cells parameter is the \n"\
        "# only relevant parameter \n")

	#
	# the keyword TRANSPORT is just introduced to enable the creation of C structures
	# wihin the solver
	#
        self.inFile.write("TRANSPORT\n")
	if self.cellsNumber == 1: self.cellsNumber = 2
        self.inFile.write("  -cells          %i\n"%self.cellsNumber)
        self.inFile.write("  -time_step          100.\n"\
                          "  -shifts          5\n"\
                          "  -lengths        0.1\n"\
                          "  -flow_direction diff\n"\
                          "  -boundary_conditions        closed closed\n"\
                          "  -print_frequency      1\n"\
                          "  -warnings False\n"\
                          "END\n")
        
        self.inFile.close()
        return None
    def setPurePhaseAmount(self,amount):
        """
        To set the amount of every mineral present in the system on each cell
        """
        self.solver.setPurePhaseAmount(amount)
	return None

    def setSolverPorosityOption(self,porosityoption):
        self.solver.setPorosityOption(porosityoption)
	return None
	
    def setTemperatureField(self,celltype,temperatureField):
        """
        Used to set the temperature field
        """
	self.solver.setTemperatureField(celltype,temperatureField)
	return None

    def end(self):
        pass

def newStatesboundsDefinition(a,nx):
    """ a est la liste qui contient le nom des tats et la limite de 
        chacun d'entre eux.
        nx est le nombre de mailles suivant la direction des x
	b est la liste renvoyee par la fonction avec les bornes des tats correctement dfinies.
	Espoir du dveloppeur
    """
    b = []
    #c = [:]
    ind = 0
    cont = 1
    max2 = 0
    for i in a:
        max2 = max(max2,i[2])
    while cont == 1:
        co = a[0][1]
	cont = 0
	ind = a.index(a[0])
        for i in a[:]:
            coe = min(co,i[1])
	    if i[1]>i[2]:
	        continue
	    if coe<co:
	        ind = a.index(i)
		cont = 1
		co = coe
        element = a[:][ind][0]
	i1 = a[:][ind][1]
	if i1 > max2:
	    break
	#
	# Maintenant, je dois chercher le 2nd indice
	# Pour cela, il faut que je compare i2 de la zone consideree aux i1 
	#
	co = a[ind][2]
	coi = co
        for i in a[:]:
            coe = min(co,i[1])
	    if coe<co and coe != i1:
	        co = coe-1
	i2 = co 
	b.append([element,i1,i2])
	a[ind][1] += nx
	if co == coi:
	    a[ind][1] = max2+1
	    a[ind][2] = max2+1
	if a[ind][1]>a[ind][2]:
	    a[ind][1] = max2+1
	    a[ind][2] = max2+1
	for i in a:
	    if i[1]<max2:
	        cont = 1
	        break
    return b
#
# internal functions
#
def _b0Writer(inFile,elements,b0):
    inFile.write("%20s %20s   %15.10e\n" %(elements[0],elements[1],b0))
_b1Writer = _b0Writer  
_b2Writer = _b0Writer  
_c0Writer = _b0Writer  
def _logKWriter(inFile,logK):
    inFile.write("%20slog_k   %15.10e\n" %(" ",logK))
def _logKCoefWriter(inFile,logKC):
    cliste = [0.0]*5
    ind = 0
    for kcoef in logKC:
        cliste[ind] = kcoef
        ind += 1
    inFile.write("%20s-analytical_expression      %15.10e %15.10e %15.10e %15.10e %15.10e\n"\
                     %(' ',cliste[0],cliste[1],cliste[2],cliste[3],cliste[4]))

def _keywordWriter(inFile,keyword,anfang,ende,comment):
    keyword+= " "*(25-len(keyword))
    inFile.write("\n%25s %i-%i %s\n" %(keyword,anfang,ende,comment))
def _zellTyp(cellType):
    if not cellType:
        cellType =  'internal'
    return cellType
 
def _reaction(inFile,formationReaction,symbol):
    string = " "
    for elementTuple in formationReaction:
        if elementTuple[1] == 1:
            string += str(elementTuple[0])+" + "
        else:
            string += str(str(elementTuple[1])+elementTuple[0])+" + "
    string = string[:-2] + " = " + str(symbol)
    inFile.write("%15s%s\n"%(" ",string))

def _formationReaction(boolean,inFile,formationReaction,symbol):
    if boolean ==0:
        string = ""
    else:
        string = str(symbol)+" = "
    for elementTuple in formationReaction:
        if elementTuple[1] == 1:
            string += str(elementTuple[0])+" + "
        elif str(elementTuple[1])[0] == "-":
	    if string[len(string)-3:] != " = ":
	        string = string[:-3]
            string += " "+str(str(elementTuple[1])+elementTuple[0])+" + "
	else:
            string += str(str(elementTuple[1])+elementTuple[0])+" + "
    if boolean ==0:
        string = string[:-2]+" = "
        string += str(symbol)
    else:
        string = string[:-2]
    inFile.write("%10s%s\n"%(" ",string))
    
    
def _speciesFormationReaction(inFile,formationReaction,symbol):
    string = ""
    for elementTuple in formationReaction:
        if elementTuple[1] == 1:
            string += str(elementTuple[0])+" + "
        elif str(elementTuple[1])[0] == "-":
	    if string[len(string)-3:]== " = ":
	        string = string
	    else:
	        string = string[:-3]
            string+=" "+str(str(elementTuple[1])+elementTuple[0])+" + "
	else:
            string += str(str(elementTuple[1])+elementTuple[0])+" + "
    string = string[:-2] + " = " + str(symbol)
    inFile.write("%10s%s\n"%(" ",string))
    
def _gamma(inFile,spezien):
    """
    used to write the gamma coefficient,
    at standard conditions:
        a = 0.509312
        b = 0.328308
    """
    
    if (spezien.coefA !=None and spezien.coefB != None):
	inFile.write("%20s-gamma   %15.10e  %s  %15.10e\n" %(" ",spezien.coefA," ",spezien.coefB))
        pass

    elif spezien.activity_law != None:
	if isInstance(spezien.activity_law,Davies):
            inFile.write("%20s-llnl_gammadavies    %15.10e\n"%(" ",spezien.activity_law.A))
        elif isInstance(spezien.activity_law,DebyeHuckel):
            inFile.write("%20s-gamma   %15.10e  %s  %15.10\n" %(" ",spezien.activity_law.A," ",spezien.activity_law.B))
	else:
	    pass    
    

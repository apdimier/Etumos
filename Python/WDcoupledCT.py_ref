"""

 Module in test phase
 
 The case to be run is in the ~/Wrapper/Tests/Chemicaltransport/Caprockintegrity/2d1 directory
                              /home/dimier/Wrapper/Tests/Chemicaltransport/Veldep/test.py
 the file is testpv2d1.py
 
 For the moment, only an aqueous saturated phase is considered.
"""
# -*- coding: utf-8 -*-
#/usr/bin/python
from generictools import GenericCTModule

from typechecktools import verifyClass, verifyClassList

from chemicaltransportmodule import ChemicalTransportModule

from hydraulicmodule import HydraulicModule

from physicallaws import IntrinsicPermeabilityLaw,\
                         KozenyCarmanLaw,\
                         VermaPruessLaw
#
# The user module is imported to enable the introduction of a new permeability function
#
from user import *

class WDcoupledCT(ChemicalTransportModule):
    """
    That class is used to enable a straightforward coupling of a:
    
        one phase Darcy flow with a chemical transport

    Initially the only enabled tools are:

        phreeqC as chemical tool

        Elmer as flow and transport tool

    The time step is evaluated in the chemical transport module.
    
    Once the elmer files are established, elmer and phreeqC are launched.
    
    The advection/diffusion solver is driven by the chemical transport module and
    
    the flow solver is driven by the WDcoupledCT module, more explicitly by its
    
    run method or its specific oneTimestep method.
    
    Due to the fixed point algorithm, the chemistry is the tool driving the time step.
    
    The hydraulic conductivity is a function of the intrinsic permeability. That one
    
    can be a function of porosity or suction.
    
    For the moment, we just update the velocity field due to the permeabiliity evolution
    
    It means that the time evolution is only bounded to permeability evolution and not to the transient term associated to specific storage.

    """
    def __init__(self,permeabilityLaw = None, hydraulicFrequency = None) :
        """
        We give here the chemical transport module.
        
        The permeability law is by default the Kozeny one
        """
        self.ChemicalTransportModule = ChemicalTransportModule
        ChemicalTransportModule.__init__(self)
#        if verifyClass(CTModule, ChemicalTransportModule):
#            print " we have a chemical transport module "
            #raw_input()
#        if self.CTModule.porosityState == "variable":
#            self.permeabilityLaw = "KozenyCarmanLaw"
#        else:
#            self.permeabilityLaw = None

        #
        self.userPermeabilityLaw = None
        self.waterDynamicViscosity = 1.e-3
        ind= -1
        if self.userProcessing:
            raw_input(" user  processing ok ")
            for method in self.processingList:
                if isinstance(method, IntrinsicPermeabilityLaw):
                    ind = self.processingList.index(method)
                    self.userPermeabilityLaw = method
                    break
        if ind>=0:
            del(self.processingList[ind])
        #
        # the hydraulic frequency corresponds to the frequency of the Darcy velocity evaluation. For the moment
        # hydraulic and chemistry share the same time step. If hydraulic frequency is zero, Darcy velocity is evaluated only once.
        #
        self.hydraulicFrequency = 1
        if (self.userPermeabilityLaw == None):
            if permeabilityLaw == None:
                self.permeabilityLaw = None
                raise Warning, " It is useless to employ that tool without defining a permeability law."
            elif isinstance(permeabilityLaw, IntrinsicPermeabilityLaw):
                                                                                                                #
                                                                                                                # available laws are described
                                                                                                                # in physicalaws.py
                                                                                                                #
                self.permeabilityLaw = permeabilityLaw
            pass

    def setHydraulicFrequency(self, newHydraulicFrequency):
        """
        The hydraulic frequency is set here. The hydraulic must be updated due to permeability evolution.
        It is set to 1 or zero. One ,if we want to evaluate hydraulic evolution over time and zero if just
        an initial velocity field is evaluated.
        """
        self.hydraulicFrequency = newHydraulicFrequency

        if self.hydraulicFrequency != 0:
            print "self.hydraulicFrequency",self.hydraulicFrequency
        else:
            self.hydraulicFrequency = -1

    def setPermeabilityLaw(self, permeabilityLaw = None):
        """
        The default permeability law is set to the Kozeny one.
        A new permeability law can be introduced via the user module.
        The permeability is an intrinsic property. It is divided by the water dynamic viscosity to obtain the hydraulic conductivity which is used
        within the Darcy law.
        
        dynamic viscosity of water: 1.e-3 Pa.s = kg/(s.m)
        
        
        """
        if permeability == None:
            from physicallaws import KozenyCarmanLaw
            self.permeabilityLaw = "KozenyCarmanLaw"
        elif isinstance (permeabilityLaw,IntrinsicPermeabilityLaw):
            self.permeabilityLaw = permeabilityLaw
        
    def getOutput (self, name):
        """
        the coupled module is launched via the chemical transport module method"
        """
        print "dbg\n",
        if "velocity" == name.lower():
            raw_input( "velocity")
            #dir(self.transportSolver)
            return self.transportSolver.getVelocity ()
            print " velocity end "
        elif "charge" == name.lower():
            raw_input( "velocity")
            #dir(self.transportSolver)
            return self.transportSolver.getCharge ()
        else:    
            raw_input( name)
            self.getOutput(name)
        
    def initialise (self):
        """
        the couple module is launched via the chemical transport module method"
        """
        self.launch()

    def run (self):
        """
        The evolution of the simulation is treated through a simple time step loop.
        """
        self.initialise()
        raw_input("initialise is over ")
        #self.transportSolver.setTimeStep(self.getTimeStep())
        #self.oneSHTimeStep ()
        raw_input(" s h  is over ")
        dthydr = 0.0
        while (self.simulatedTime < self.times[-1]): # should be replaced by the call of oneCoupledTimeStep within the while
            dt = self.getTimeStep()
            dthydr += dt
            self.oneTimeStep ()
            if self.hydraulicFrequency  != 0:
                if self.timeStepNumber % self.hydraulicFrequency==0:
                    print " WDcoupledCT dbg permeability evaluation",dthydr
                    self.transportSolver.setTimeStep(dthydr)
                    if self.permeabilityLaw != None:
                        self.transportSolver.setPermeability(self.permeabilityLaw(porosity)/self.waterDynamicViscosity)
                    self.oneSHTimeStep ()

                    dthydr = 0.

    def oneSHTimeStep (self):
        """
        That method is used to solve the saturated transient flow.
        """
        print " wd coupled oneSHTimeStep "
        self.transportSolver.SaturatedHydraulicOneTimeStep ()
        return None

    def oneCoupledTimeStep (self):
        """
        The evolution of the simulation is treated through a simple time step loop.
        """
        self.oneTimeStep()
        dt_chemistry = self.getTimeStep()
        #
        # new evaluation of the velocity field
        #
        if self.hydraulicFrequency != 0:
            #
            # new evaluation of the velocity field
            #
            if self.timeStepNumber % self.hydraulicFrequency==0:
                print " WDcoupledCT dbg permeability evaluation"
                #porosityField = self.ChemicalTransportModule.chemicalSolver.getPorosityField()
                newPermeability = [self.permeabilityLaw(porosity) for porosity in self.ChemicalTransportModule.chemicalSolver.getPorosityField()]
                print " WDcoupledCT dbg -> permeability update"
                self.transportSolver.setPermeabilityField(newPermeability)
                self.transportSolver.setTimeStep(dt_hydraulic)
                #
                # Il faut verifier que la vitesse est recuperee, sinon une methode doit etre creee.
                # 
                #
                self.oneSHTimeStep()
                raw_input(" WDcoupledCT dbg permeability evaluation")
                dt_hydraulic = 0.
            else:
                dt_hydraulic += dt_chemistry
        pass

    def stop(self):
        return None
